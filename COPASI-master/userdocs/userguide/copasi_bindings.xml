<chapter id="bindings" xreflabel="bindings">
<!-- Begin CVS Header -->
<!--   $Source: /Volumes/Home/Users/shoops/cvs/copasi_dev/userdocs/userguide/copasi_bindings.xml,v $ -->
<!--   $Revision: 1.13 $ -->
<!--   $Name:  $ -->
<!--   $Author: gauges $ -->
<!--   $Date: 2011/12/23 19:56:18 $ -->
<!-- End CVS Header -->

<!-- Copyright (C) 2011 - 2010 by Pedro Mendes, Virginia Tech Intellectual -->
<!-- Properties, Inc., University of Heidelberg, and The University -->
<!-- of Manchester. -->
<!-- All rights reserved. -->

<!-- Copyright (C) 2008 by Pedro Mendes, Virginia Tech Intellectual -->
<!-- Properties, Inc., EML Research, gGmbH, University of Heidelberg, -->
<!-- and The University of Manchester. -->
<!-- All rights reserved. -->

<title condition="JAVA">Java</title>
<title condition="CPP">C++</title>
<title condition="PYTHON">Python</title>
<sect1 id="Introduction">
<title>Introduction</title>
<para>
This document tries to give a superficial overview of the COPASI backend API. This documentation is in no way meant to give a complete reference to the API. It is only intended to give the programmer that wants to use the library or the language bindings an overview of the classes and some examples on how certain things can be done.
The language bindings expose parts of the underlying C++ API and so far no attempt has been made to simplify the API to better fit the target language or to make it easier for the programmer. All there is so far is a way to use COPASIs classes and methods from several languages.
</para>
</sect1>
<sect1 condition="CPP" id="initialization">
<title>Initialization of the library</title>
<para>
Before the COPASI backend library can be used in C++, it has to be initialized.
Initialization should be done as follows:
</para>
<para>
<programlisting>
// initializes the root container
// argc and argv are the parameters that the main rountine gets
// alternatively, 0 and NULL may be passed as argc and argv.
CCopasiRootContainer::init(argc, argv);
</programlisting>
</para>
<para>
It is best to do the initialization in a try...catch block.
</para>
<para>
In order to destroy the root container, e.g. at the end of the program, there is the static method CCopasiRootContainer::destroy.
</para>
<para>
Normally, init should only be called once at the beginning of a program and destroy at the end of the program. If needed, the current root container can also be deleted in the middle of a running program and you first have to delete the old root container if you want to initialize a new one with init. 
</para>
<para>
In order to be more portable, the C++ backend of COPASI makes extensive use of typedefs for several datatypes. All those typedefs can be found in the copasi.h header file which has to be included by all programs that want to use the COPASI backend library in a C++ program.
</para>
<para>
And last, but not least, the statement "#define COPASI_MAIN" should occur at the very beginning (before copasi.h is included) of your source file that contains the main routine, otherwise, you will not be able to link against the COPASI library.
</para>
</sect1>

<sect1 id="CCopasiRootContainer" xreflabel="CCopasiRootContainer">
<title>CCopasiRootContainer</title>

<para>
In the COPASI backend, currently everything is located in an instance of CCopasiRootContainer. There is only one root container.
</para>

<para>
The CCopasiRootContainer class has a number of other useful methods that allow the user to aquire handles to the function database or
the list of datamodels.
</para>

<para>
The COPASI backend only contains a single function database which contains all predefined and user defined function definitions. This function database is shared by all datamodels.
In order to get a pointer to this function database, you can use the static method getFunctionList in CCopasiContainer. The method takes no arguments and returns a pointer to the function database which is an instance of the class CFunctionDB.
</para>

<para>
The other important data structure that is located in the root container is the list of datamodels. Earlier versions of the COPASI backend could only handle on datamodel at a time, but newer versions now allow the user to work with several datamodels at the same time.
</para>

<para>
After the root container has been initialized by calling init, it does not contain any datamodel yet. In order to create a new datamodel and add it to the root container, you have to call the static method addDatamodel in CCopasiRootContainer. The method takes no arguments and returns a pointer to the newly created instance of CCopasiDataModel. Since the datamodel is owned by the root container, it will be deleted when the root container is deleted.
</para>

<para>
In order to get the list of all datamodels, there is a static method in CCopasiContainer called getDatamodelList.
</para>
</sect1>

<sect1 id="CCopasiDataModel" xreflabel="CCopasiDataModel">
<title>CCopasiDataModel</title>

<para>
CCopasiDataModel is the class the contains the actual model, all tasks and all output definitions (report and plots).
</para>

<para>
In order to create a new model, you can call the static method addDatamodel in CCopasiRootContainer which will return the newly created datamodel. Or if the datamodel already has been created, you can get it via its index in the list of datamodels which you can get from the root container by calling getDatamodelList.
</para>

<para>
getDataModelList returns a list of the datamodels that have been created. This list has a method size to query the number of datamodels it contains.
</para>

<para>
If you want to delete a datamodel before the end of your program, CCopasiVector has a method remove which you can call with an index. This call will remove the object at the given index from the vector and free the memory that was allocated for it.  
</para>

<para>
<caution>Currently, it is not a good idea to change the name of a datamodel instance (e.g. by calling setObjectName). The backend relies on the datamodel to have a certain name and if that name changes, the backend will stop working for that datamodel. We hope to fix this problem in upcoming releases of COPASI.</caution>
</para>

<para>
<emphasis>CCopasiDataModel</emphasis> contains the actual model which can be obtained with the method <emphasis>getModel()</emphasis>, the defined tasks which can be obtained with the method <emphasis>getTaskList()</emphasis>, the reports which are obtained via the method <emphasis>getReportDefinitionList()</emphasis> and the function database which can be obtained with the <emphasis>getFunctionList()</emphasis>.
In addition to these methods <emphasis>CCopasiDataModel</emphasis> provides some methods for loading COPASI files or importing SBML files, for saving COPASI files or exporting SBML files, for creating new models and for adding tasks to the task list.
</para>
</sect1>

<sect1 id="model">
<title>Working with the model</title>

<sect2 id="modeConcept">
<title>COPASIs Model Concept</title>

<para>
The CCopasiDataModel class contains the actual model as well as the tasks and all the output definitions (plots and reports). Newer versions of COPASI allow the user to work with several instances of the CCopasiDataModel class at the same time. 
</para>
<para>
New instances can be create by the static method addDatamodel in CCopasiRootContainer and a list of the already created datamodels can be acquired with the static method getDatamodelList also from CCopasiRootContainer.
</para>

<para>
<emphasis>CCopasiDataModel</emphasis> contains the actual model which can be obtained with the method <emphasis>getModel()</emphasis>, the defined tasks which can be obtained with the method <emphasis>getTaskList()</emphasis>, the reports which are obtained via the method <emphasis>getReportDefinitionList()</emphasis> and the function database which can be obtained with the <emphasis>getFunctionList()</emphasis>.
In addition to these methods <emphasis>CCopasiDataModel</emphasis> provides some methods for loading COPASI files or importing SBML files, for saving COPASI files or exporting SBML files, for creating new models and for adding tasks to the task list.
</para>
</sect2>

<sect2 id="modelElements" xreflabel="modelElements">
<title>Model Elements</title>

<para>
The class in COPASI that contains the actual model data is <emphasis>CModel</emphasis>. The model can be obtained from the instance of <emphasis>CCopasiDataModel</emphasis> via the <emphasis>getModel()</emphasis> method. To create a new empty model, <emphasis>CCopasiDataModel</emphasis> provides the method <emphasis>newModel()</emphasis>. There is also the method <emphasis condition="JAVA">loadModel(String filename)</emphasis><emphasis condition="CPP">loadModel(std::string filename)</emphasis><emphasis condition="PYTHON">loadModel(FILENAME_STRING)</emphasis> which loads a COPASI model from the given filename, the method <emphasis condition="JAVA">importSBML(String filename)</emphasis><emphasis condition="CPP">importSBML(std::string filename)</emphasis><emphasis condition="PYTHON">importSBML(FILENAME_STRING)</emphasis> which imports an SBML model from the file with the given name and last but not least the method <emphasis condition="JAVA">importSBMLFromString(String sbmlModelText)</emphasis><emphasis condition="CPP">importSBMLFromString(std::string sbmlModelText)</emphasis><emphasis condition="PYTHON">importSBMLFromString(SBML_CONTENT_STRING)</emphasis> which imports an SBML model from the given string. The string must be a valid SBML model string. All three methods return a boolean value which is <emphasis condition="CPP">true</emphasis><emphasis condition="JAVA">true</emphasis><emphasis condition="PYTHON">True</emphasis> if the method succeeded and <emphasis condition="CPP">false</emphasis><emphasis condition="JAVA">false</emphasis><emphasis condition="PYTHON">False</emphasis> otherwise. 
</para>

<para>
Once the model has been obtained, it can be manipulated in many ways. New model elements like compartments, metabolites, reactions, events and/or global parameters can be created, modified or removed. The model also has some methods to manipulate the time-, volume- and substance units of the model. Unlike SBML, models in COPASI only have global units and the units of all elements of the model are made up of these global units. Units on individual elements are not supported.
</para>

<para>
To find out how many compartments, metabolites, reactions, events or global parameters (model values) a model has, <emphasis>CModel</emphasis> has the following methods.
</para>

<para>
<programlisting condition="JAVA">
// return the number of compartments in the model
long getNumCompartments(); 
// return the number of metabolites in the model
long getNumMetabs(); 
// return the number of global parameters in the model
long getNumModelValues();
// return the number of reactions in the model
long getNumReactions(); 
// return the number of events in the model
long getNumEvents(); 
</programlisting>
<programlisting condition="CPP">
// return the number of compartments in the model
C_INT32 getCompartments().size();
// return the number of metabolites in the model
C_INT32 getMetabolites().size();
// return the number of global parameters in the model
C_INT32 getModelValues().size();
// return the number of reactions in the model
C_INT32 getReactions().size();
// return the number of events in the model
C_INT32 getEvents().size();
</programlisting>
<programlisting condition="PYTHON">
# return the number of compartments in the model
getNumCompartments()
# return the number of metabolites in the model
getNumMetabs()
# return the number of global parameters in the model
getNumModelValues()
# return the number of reactions in the model
getNumReactions()
# return the number of events in the model
getNumEvetns()
</programlisting>
</para>

<para>
To obtain a specific model element there are the following methods:
</para>

<para>
<programlisting condition="JAVA">
CCompartment getCompartment(long index);
CMetab getMetabolite(long index);
CModelValue getModelValue(long index);
CReaction getReaction(long index);
CEvent getEvent(long index);
</programlisting>
<programlisting condition="CPP">
CCompartment* getCompartments()[const unsigned C_INT32&amp; index];
CMetab* getMetabolites()[const unsigned C_INT32&amp; index];
CModelValue* getModelValues()[const unsigned C_INT32&amp; index];
CReaction* getReactions()[const unsigned C_INT32&amp; index];
CEvent* getEvents()[const unsigned C_INT32&amp; index];
</programlisting>
<programlisting condition="PYTHON">
getCompartment(INDEX)
getMetabolite(INDEX)
getModelValue(INDEX)
getReaction(INDEX)
getEvent(INDEX)
</programlisting>
</para>

<para>
New model elements can be created with the following methods:
</para>

<para>
<programlisting condition="JAVA">
/**
 * Creates a new compartment with the given name 
 * and an initial volume of 1.0 volume units.
 * The newly created compartment is added to the model
 * and the method also returns the new instance.
 * If the method fails, null is returned.
 */
CCompartment createCompartment(String name);

/**
 * Creates a new compartment with the given name 
 * and initial volume.
 * The newly created compartment is added to the model
 * and the method also returns the new instance.
 * If the method fails, null is returned.
 */
CCompartment createCompartment(String name,double volume);

/**
 * Creates a new metabolite with the given name and an 
 * initial concentration of 1.0 substance units/volume units.
 * The metabolite is added to the compartment that is specified
 * as the second argument.
 * The newly created metabolite is added to the model and
 * the method also returns the new instance.
 * If the method fails, null is returned.
 */
CMetab createMetabolite(String name, String compartment);

/**
 * Creates a new metabolite with the given name and 
 * initial concentration.
 * The metabolite is added to the compartment that is 
 * specified as the second argument.
 * The newly created metabolite is added to the model and the
 * method also returns the new instance.
 * If the method fails, null is returned.
 */
CMetab createMetabolite(String name, String compartment, double iconc);

/**
 * Creates a new model value with the given name and 
 * an initial value of 0.0.
 * The newly created model value is added to the model
 * and the method also returns the new instance.
 * If the method fails, null is returned.
 */
CModelValue createModelValue(String name);

/**
 * Creates a new model value with the given name 
 * and initial value.
 * The newly created model value is added to the model
 * and the method also returns the new instance.
 * If the method fails, null is returned.
 */
CModelValue createModelValue(String name, double value);

/**
 * Creates a new reaction with the given name.
 * The newly created reaction is added to the model and 
 * the method also returns the reaction instance.
 */
CReaction createReaction(String name);

/**
 * Creates a new event with the given name.
 * The newly created event is added to the model and 
 * the method also returns the event instance.
 */
CEvent createEvent(String name);
</programlisting>
<programlisting condition="CPP">
/**
 * Creates a new compartment with the given name 
 * and an initial volume of 1.0 volume units if no
 * volume is given. If a volume is given, the initial 
 * volume will be set to that value.
 * The newly created compartment is added to the model
 * and the method also returns a pointer to the new instance.
 * If the method fails, NULL is returned.
 */
CCompartment* createCompartment(const std::string&amp; name, const C_FLOAT64&amp; volume = 1.0);

/**
 * Creates a new metabolite with the given name. 
 * The metabolite is added to the compartment that is specified
 * as the second argument.
 * If a value for the initial concentration is given, the initial 
 * concentration is set to that value, otherwise the
 * initial concentration is set to 1.0 substance units/volume units.
 * The newly created metabolite is added to the model and
 * the method also returns the new instance.
 * If the method fails, NULL is returned.
 */
CMetab* createMetabolite(const std::string&amp; name,
                         const std::string&amp; compartment
                         const C_FLOAT64&amp; iconc = 1.0);


/**
 * Creates a new model value with the given name 
 * and initial value.
 * If no initial value is given, it is assumed to be 0.0.
 * The newly created model value is added to the model
 * and the method also returns the new instance.
 * If the method fails, NULL is returned.
 */
CModelValue* createModelValue(const std::string name, const C_FLOAT64&amp; value = 0.0);

/**
 * Creates a new reaction with the given name.
 * The newly created reaction is added to the model and 
 * the method also returns the reaction instance.
 * If the method fails, NULL is returned.
 */
CReaction* createReaction(const std::string&amp; name);

/**
 * Creates a new event with the given name.
 * The newly created event is added to the model and 
 * the method also returns the event instance.
 * If the method fails, NULL is returned.
 */
CEvent* createEvent(const std::string&amp; name);
</programlisting>
<programlisting condition="PYTHON">
# 
# Creates a new compartment with the given name 
# and an initial volume of 1.0 volume units.
# The newly created compartment is added to the model
# and the method also returns the new instance.
# If the method fails, None is returned.
# 
COMPARTMENT=createCompartment(NAME_STRING)

# 
# Creates a new compartment with the given name 
# and initial volume.
# The newly created compartment is added to the model
# and the method also returns the new instance.
# If the method fails, None is returned.
# 
COMPARTMENT=createCompartment(NAME_STRING,VOLUME)

# 
# Creates a new metabolite with the given name and an 
# initial concentration of 1.0 substance units/volume units.
# The metabolite is added to the compartment that is specified
# as the second argument.
# The newly created metabolite is added to the model and
# the method also returns the new instance.
# If the method fails, None is returned.
# 
METABOLITE=createMetabolite(NAME_STRING, COMPARTMENT_NAME_STRING)

# 
# Creates a new metabolite with the given name and 
# initial concentration.
# The metabolite is added to the compartment that is 
# specified as the second argument.
# The newly created metabolite is added to the model and the
# method also returns the new instance.
# If the method fails, None is returned.
# 
METABOLITE=createMetabolite(NAME_STRING, COMPARTMENT_NAME_STRING, CONCENTRATION)

# 
# Creates a new model value with the given name and 
# an initial value of 0.0.
# The newly created model value is added to the model
# and the method also returns the new instance.
# If the method fails, None is returned.
# 
MODEL_VALUE=createModelValue(NAME_STRING)

# 
# Creates a new model value with the given name 
# and initial value.
# The newly created model value is added to the model
# and the method also returns the new instance.
# If the method fails, None is returned.
# 
MODEL_VALUE=createModelValue(NAME_STRING, VALUE)

# 
# Creates a new reaction with the given name.
# The newly created reaction is added to the model and 
# the method also returns the reaction instance.
# 
REACTION=createReaction(NAME_STRING)

# 
# Creates a new event with the given name.
# The newly created event is added to the model and 
# the method also returns the event instance.
# 
EVENT=createEvent(NAME_STRING)
</programlisting>
</para>

<para>
Naturally model elements can also be removed via their keys. Each object in COPASI which is derived from <emphasis>CCopasiObject</emphasis> gets a unique id when it is created which in COPASI is called key. To get the key for such an object, <emphasis>CCopasiObject</emphasis> provides the method <emphasis>getKey()</emphasis>.
<emphasis>CModel</emphasis>, <emphasis>CCompartment</emphasis>, <emphasis>CMetab</emphasis>, <emphasis>CModelValue</emphasis> and <emphasis>CReaction</emphasis> are all derived from <emphasis>CCopasiObject</emphasis> and you can therefore get the key for any of them via the <emphasis>getKey()</emphasis> method which returns the key in the form of a string.
</para>

<para>
The methods to delete elements from the model are:
</para>

<para>
<programlisting condition="JAVA">
boolean removeCompartment(String key);
boolean removeMetabolite(String key);
boolean removeModelValue(String key);
boolean removeReaction(String key);
boolean removeEvent(String key);
</programlisting>
<programlisting condition="CPP">
bool removeCompartment(const std::string&amp; key);
bool removeMetabolite(const std::string&amp; key);
bool removeModelValue(const std::string&amp; key);
bool removeReaction(const std::string&amp; key);
bool removeEvent(const std::string&amp; key);
</programlisting>
<programlisting condition="PYTHON">
# each function get the key of the object that is to be removed
# as the argument and return True or False depending on whether the remove
# operation succeeded
SUCCESS=removeCompartment(KEY_STRING)
SUCCESS=removeMetabolite(KEY_STRING)
SUCCESS=removeModelValue(KEY_STRING)
SUCCESS=removeReaction(KEY_STRING)
SUCCESS=removeEvent(KEY_STRING)
</programlisting>
</para>

<para>
These methods also delete all dependent objects. So if a compartment is deleted, all metabolites in that compartment are also deleted and if those metabolites were part of reaction those reactions are deleted as well.
</para>

<para>
For example, to delete the third metabolite in the model you could write the following code (provided that there are at least three metabolites in the model):
</para>

<para>
<programlisting condition="JAVA">
CModel model=datamodel.getModel();
CMetab metab=model.getMetabolite(3);
String key=metab.getKey();
model.removeMetabolite(key);
</programlisting>
<programlisting condition="CPP">
CModel* pModel=pDatamodel->getModel();
CMetab* pMetab=pModel->getMetabolite(3);
std::string key=pMetab->getKey();
pModel->removeMetabolite(key);
</programlisting>
<programlisting condition="PYTHON">
model=datamodel.getModel()
metab=model.getMetabolite(3)
key=metab.getKey()
model.removeMetabolite(key)
</programlisting>
</para>

<para>
Other methods that might be of interest in the CModel class are e.g. the methods to calculate 
the jacobian matrix and the reduced jacobian matrix of the model (see example 8).
</para>

<para>
<programlisting condition="JAVA">
/**
 * Calculates the jacobian of the full model for the current state
 * and stores it in the provided matrix. applyInitialValues()
 * needs to be called before.
 * @param FloatMatrix jacobian
 * @param double derivationFactor,
 * @param double resolution
 */
void calculateJacobian(FloatMatrix jacobian,
                       double derivationFactor,
                       double resolution);

/**
 * Calculates the Jacobian of the reduced model for the current
 * state and stores it in the provided matrix. applyInitialValues()
 * needs to be called before.
 * @param double derivationFactor,
 * @param double resolution
 * @param FloatMatrix jacobianX
 */
void calculateJacobianX(FloatMatrix jacobianX,
                        double derivationFactor,
                        double resolution);

/**
 * initialize all values of the model with their initial values
 */
void applyInitialValues();
</programlisting>
<programlisting condition="CPP">
/**
 * Calculates the jacobian of the full model for the current state
 * and stores it in the provided matrix. applyInitialValues()
 * needs to be called before.
 * @param CMatrix&lt; C_FLOAT64 &gt; &amp; jacobian
 * @param const C_FLOAT64 &amp; derivationFactor,
 * @param const C_FLOAT64 &amp; resolution
 */
void calculateJacobian(CMatrix&lt; C_FLOAT64 &gt; &amp; jacobian,
                       const C_FLOAT64 &amp; derivationFactor,
                       const C_FLOAT64 &amp; resolution);

/**
 * Calculates the Jacobian of the reduced model for the current
 * state and stores it in the provided matrix. applyInitialValues()
 * needs to be called before.
 * @param const C_FLOAT64 &amp; derivationFactor,
 * @param const C_FLOAT64 &amp; resolution
 * @param CMatrix&lt; C_FLOAT64 &gt; &amp; jacobianX
 */
void calculateJacobianX(CMatrix&lt; C_FLOAT64 &gt; &amp; jacobianX,
                        const C_FLOAT64 &amp; derivationFactor,
                        const C_FLOAT64 &amp; resolution);

/**
 * initialize all values of the model with their initial values
 */
void applyInitialValues();
</programlisting>
<programlisting condition="PYTHON">
/**
 * Calculates the jacobian of the full model for the current state
 * and stores it in the provided matrix. applyInitialValues()
 * needs to be called before.
 * @param FloatMatrix jacobian
 * @param double derivationFactor,
 * @param double resolution
 */
calculateJacobian(jacobian,
                  derivationFactor,
                  resolution)

/**
 * Calculates the Jacobian of the reduced model for the current
 * state and stores it in the provided matrix. applyInitialValues()
 * needs to be called before.
 * @param double derivationFactor,
 * @param double resolution
 * @param FloatMatrix jacobianX
 */
calculateJacobianX(jacobianX,
                   derivationFactor,
                   resolution)

/**
 * initialize all values of the model with their initial values
 */
applyInitialValues()
</programlisting>
</para>

<sect3 id="modelEntity" xreflabel="modelEntity">
<title>CModelEntity</title>

<para>
In COPASI the classes for the model itself, for compartments, metabolites and global parameters are derived from <emphasis>CModelEntity</emphasis> and inherit all its methods.
Most of the time, if you manipulate any of those classes, it will be done through methods from <emphasis>CModelEntity</emphasis>.
<emphasis>CModelEntity</emphasis> provides the following methods:
</para>

<para>
<programlisting condition="JAVA">
/**
 * Gets the status of the entity.
 */
int getStatus();

/**
 * sets the status of an entity.
 */
void setStatus(int status);

/**
 * gets the transient value of an entity.
 */
double getValue();

/**
 * Returns the initial value of an entity.
 */
double getInitialValue();

/**
 * Sets the initial value of an entity.
 */
void setInitialValue(double initialValue);

/**
 * Returns the SBML id of an entity. If none has been set,
 * an empty string is returned.
 */
String getSBMLId();

/**
 * Sets the SBML id on an entity.
 * This is either done on importing an SBML file,
 * or on exporting a model.
 * Don't mess with this since it might break further
 * exports to SBML.
 */
void setSBMLId(String id);

/**
 * If the entity is determined by an assignment or 
 * an ODE, this method will return the mathematical
 * expression for the assignment or the ODE.
 */
String getExpression();

/**
 * With this method, the mathematical expression 
 * for entities that are determined by an assignment
 * or an ODE can be set.
 * You might also have to set the status of the entity
 * to indicate that it is now determined by an ODE 
 * or an assignment. (see setStatus())
 */
boolean setExpression(String expression);

/**
 * Returns the mathematical expression for any initial 
 * assignment that might have been set on the entity. 
 * This is independent of the status of the entity.
 */
String getInitialExpression();

/**
 * With this method, the mathematical expression 
 * for the initial assignment of an entity can be set.
 */
boolean setInitialExpression(String expression);
</programlisting>
<programlisting condition="CPP">
/**
 * Gets the status of the entity.
 */
const CModelEntity::Status&amp; getStatus() const;

/**
 * sets the status of an entity.
 */
void setStatus(const CModelEntity::Status&amp; status);

/**
 * gets the transient value of an entity.
 */
const C_FLOAT64&amp; getValue() const;

/**
 * Returns the initial value of an entity.
 */
const C_FLOAT64&amp; getInitialValue() const;

/**
 * Sets the initial value of an entity.
 */
void setInitialValue(const C_FLOAT64&amp; initialValue);

/**
 * Returns the SBML id of an entity. If none has been set,
 * an empty string is returned.
 */
const std::string&amp; getSBMLId() const;

/**
 * Sets the SBML id on an entity.
 * This is either done on importing an SBML file,
 * or on exporting a model.
 * Don't mess with this since it might break further
 * exports to SBML.
 */
void setSBMLId(const std::string&amp; id);

/**
 * If the entity is determined by an assignment or 
 * an ODE, this method will return the mathematical
 * expression for the assignment or the ODE.
 */
std::string getExpression() const;

/**
 * With this method, the mathematical expression 
 * for entities that are determined by an assignment
 * or an ODE can be set.
 * You might also have to set the status of the entity
 * to indicate that it is now determined by an ODE 
 * or an assignment. (see setStatus())
 */
bool setExpression(cosnt std::string&amp; expression);

/**
 * Returns the mathematical expression for any initial 
 * assignment that might have been set on the entity. 
 * This is independent of the status of the entity.
 */
std::string getInitialExpression() const;

/**
 * With this method, the mathematical expression 
 * for the initial assignment of an entity can be set.
 */
bool setInitialExpression(const std::string&amp; expression);
</programlisting>
<programlisting condition="PYTHON">
# 
# Gets the status of the entity.
# 
STATUS=getStatus()

# 
# sets the status of an entity.
# 
setStatus(STATUS)

# 
# gets the transient value of an entity.
# 
VALUE=getValue()

# 
# Returns the initial value of an entity.
# 
VALUE=getInitialValue()

# 
# Sets the initial value of an entity.
# 
setInitialValue(VALUE)

# 
# Returns the SBML id of an entity. If none has been set,
# an empty string is returned.
# 
ID_STRING=getSBMLId()

# 
# Sets the SBML id on an entity.
# This is either done on importing an SBML file,
# or on exporting a model.
# Don't mess with this since it might break further
# exports to SBML.
# 
setSBMLId(ID_STRING)

# 
# If the entity is determined by an assignment or 
# an ODE, this method will return the mathematical
# expression for the assignment or the ODE.
# 
EXPRESSION_STRING=getExpression()

# 
# With this method, the mathematical expression 
# for entities that are determined by an assignment
# or an ODE can be set.
# You might also have to set the status of the entity
# to indicate that it is now determined by an ODE 
# or an assignment. (see setStatus())
# 
SUCCESS=setExpression(EXPRESSION_STRING)

# 
# Returns the mathematical expression for any initial 
# assignment that might have been set on the entity. 
# This is independent of the status of the entity.
# 
EXPRESSION_STRING=getInitialExpression()

# 
# With this method, the mathematical expression 
# for the initial assignment of an entity can be set.
# 
SUCCESS=setInitialExpression(EXPRESSION_STRING)
</programlisting>
</para>

<para>
The <emphasis>setStatus(int status)</emphasis> and <emphasis>getStatus()</emphasis> methods set and return the status of an entity respectively. The status of an entity determines how it is calculated. E.g. an entity that has a status of FIXED is not changed during a time course simulation, whereas an entity that has a status value of ASSIGNMENT is determined by an assignment expression. For a full list of valid status definitions see table <link linkend="ModelEntityStatus">model entity status</link>.
</para>

<para>
<table xreflabel="ModelEntityStatus" id="ModelEntityStatus">
<title>model entity status</title>
<tgroup cols="2">
<thead>
<row>
<entry>state</entry>
<entry>description</entry>
</row>
</thead>
<tbody>
<row>
<entry>FIXED</entry>
<entry>entity is fixed</entry>
</row>
<row>
<entry>ASSIGNMENT</entry>
<entry>entity is determined by an assignment</entry>
</row>
<row>
<entry>REACTIONS</entry>
<entry>entity is determined by reactions (only applicable to metabolites)</entry>
</row>
<row>
<entry>ODE</entry>
<entry>entity is determined by an ode</entry>
</row>
<row>
<entry>TIME</entry>
<entry>this is the only state the model itself can have</entry>
</row>
</tbody>
</tgroup>
</table>
</para>
</sect3>

<sect3 id="compartment" xreflabel="compartment">
<title>compartment</title>

<para>
The <emphasis>CCompartment</emphasis> class is derived from <emphasis>CModelEntity</emphasis> and inherits all its methods. Compartments can have the status FIXED, ASSIGNMENT or ODE. And you can set the corresponding mathematical expressions for the assignment or ODE through the methods provided by <emphasis>CModelEntity</emphasis>. You can also either set an initial value or a mathematical expression that determines the initial value of the compartment.
In addition to the methods provided by <emphasis>CModelEntity</emphasis>, <emphasis>CCompartment</emphasis> provides some methods to handle the metabolites in a compartment.
</para>

<para>
<programlisting condition="JAVA">
/**
 * Returns a MetabVectorNS object which contains 
 * all metabolites that are contained in the compartment.
 * MetabVectorNS has a size method to determine the
 * number of metabolites and a get method that takes an 
 * index and returns the metabolite at that index.
 */
MetabVectorNS getMetabolites();

/**
 * Adds the given metabolite to the compartment.
 * If the operation succeeded, true is returned, else false.
 */
boolean addMetabolite(CMetab metabolite);

/**
 * Removes the given metabolite from the compartment.
 * If the operation succeeded, true is returned, else false.
 * This method is obsolete and should no longer be used.
 * Future versions of the bindings might not contain this method.
 */
boolean removeMetabolite(CMetab metabolite);
</programlisting>
<programlisting condition="CPP">
/**
 * Returns a CCopasiVectorNS&lt;CMetab&gt; object which contains 
 * all metabolites that are contained in the compartment.
 * CCopasiVectorNS has a size method to determine the
 * number of metabolites and a get method that takes an 
 * index and returns the metabolite at that index.
 * If you need to remove a metabolite from a compartment, 
 * the vector also has a method remove which takes the pointer
 * to the object that needs to be removed as the argument.
 */
CCopasiVectorNS&lt;CMetab&gt;&amp; getMetabolites();
const CCopasiVectorNS&lt;CMetab&gt;&amp; getMetabolites() const;

/**
 * Adds the given metabolite to the compartment.
 * If the operation succeeded, true is returned, else false.
 */
bool addMetabolite(CMetab* pMetabolite);
</programlisting>
<programlisting condition="PYTHON">
# 
# Returns a MetabVectorNS object which contains 
# all metabolites that are contained in the compartment.
# MetabVectorNS has a size method to determine the
# number of metabolites and a get method that takes an 
# index and returns the metabolite at that index.
# 
MATABOLITE_VECTOR=getMetabolites()

# 
# Adds the given metabolite to the compartment.
# If the operation succeeded, true is returned, else false.
# 
SUCCESS=addMetabolite(METABOLITE_INSTANCE)

# 
# Removes the given metabolite from the compartment.
# If the operation succeeded, true is returned, else false.
# This method is obsolete and should no longer be used.
# Future versions of the bindings might not contain this method.
# 
SUCCESS=removeMetabolite(METABOLITE_INSTANCE)
</programlisting>
</para>
</sect3>

<sect3 id="metabolites" xreflabel="metabolites">
<title>metabolites</title>

<para>
Just like the compartment class, the class for metabolites, <emphasis>CMetab</emphasis> is derived from <emphasis>CModelEntity</emphasis> and inherits all its methods.
Metabolites can have the status FIXED, ASSIGNMENT, ODE or REACTIONS. And you can set the corresponding mathematical expressions for the assignment or ODE through the methods provided by <emphasis>CModelEntity</emphasis>. You can also either set an initial value or a mathematical expression that determines the initial value of the metabolite. Using the methods from <emphasis>CModelEntity</emphasis> to set or get values from a metabolite means that you get or set the particle number of the metabolite. If you want to work with concentrations rather than particle numbers, <emphasis>CMetab</emphasis> provides the methods <emphasis>getConcentration()</emphasis>, <emphasis>getInitialConcentration()</emphasis> and <emphasis>setInitialConcentration(double c)</emphasis> to get the concentration, initial concentration or set the initial concentration respectively. The class also provides the method <emphasis>getCompartment()</emphasis> which returns the compartment of the metabolite.
</para>
</sect3>

<sect3 id="modelValues" xreflabel="modelvalues">
<title>model values (global parameters)</title>

<para>
In COPASI global parameters are called model values and the corresponding class is <emphasis>CModelValue</emphasis> which is also derived from <emphasis>CModelEntity</emphasis>. A global parameter can also be determined by an assignment or an ODE or it can be fixed. Global parameters can also have initial assignments.
</para>
</sect3>

<sect3 id="reactions" xreflabel="reactions">
<title>reactions</title>

<para>
The class for reaction is called <emphasis>CReaction</emphasis>. It contains information on the metabolites taking part in the reaction as substrates, products or modifiers and about the kinetic law.
</para>

<para>
<programlisting condition="JAVA">
/**
 * Returns the current flux of the reaction.
 */
double getFlux();

/**
 * Returns the current flux of the reaction in terms 
 * of particle numbers rather than concentrations
 */
double getParticleFlux();

/**
 * If the reaction is reversible, this returns true, else false.
 */
boolean isReversible();

/**
 * Sets whether the reaction is reversible or not.
 */
void setReversible(boolean reversible);

/**
 * Returns the number of compartments that are involved
 * in this reaction.
 */
long getCompartmentNumber();

/**
 * Returns the SBML id of the reaction if one has been set,
 * otherwise an empty string is returned.
 */
String getSBMLId();

/**
 * Sets the SBML id of the reaction.
 * This is done during import of an SBML model, or
 * during the first export of an SBML model.
 * If you change the SBML id of any entity, further 
 * exports to SBML might fail.
 */
void setSBMLId(String id);

/**
 * Returns the chemical equation object of the reaction.
 */
CChemEq getChemEq();

/**
 * Returns the function for the kinetic law used in the reaction.
 */
CFunction getFunction();

/**
 * Sets the kinetic law of the reaction via a functions name.
 * A function with that name must exist in the function database.
 */
boolean setFunction(String functionName);
</programlisting>
<programlisting condition="CPP">
/**
 * Returns the current flux of the reaction.
 */
const C_FLOAT64&amp; getFlux();

/**
 * Returns the current flux of the reaction in terms 
 * of particle numbers rather than concentrations
 */
const C_FLOAT64&amp; getParticleFlux();

/**
 * If the reaction is reversible, this returns true, else false.
 */
bool isReversible();

/**
 * Sets whether the reaction is reversible or not.
 */
void setReversible(bool reversible);

/**
 * Returns the number of compartments that are involved
 * in this reaction.
 */
unsigned C_INT32 getCompartmentNumber() const;

/**
 * Returns the SBML id of the reaction if one has been set,
 * otherwise an empty string is returned.
 */
const std::string&amp; getSBMLId() const;

/**
 * Sets the SBML id of the reaction.
 * This is done during import of an SBML model, or
 * during the first export of an SBML model.
 * If you change the SBML id of any entity, further 
 * exports to SBML might fail.
 */
void setSBMLId(const std::string&amp; id);

/**
 * Returns the chemical equation object of the reaction.
 */
const CChemEq&amp; getChemEq() const;
CChemEq&amp; getChemEq();

/**
 * Returns the function for the kinetic law used in the reaction.
 */
CFunction* getFunction();

/**
 * Sets the kinetic law of the reaction via a functions name.
 * A function with that name must exist in the function database.
 */
bool setFunction(const std::string&amp; functionName);
</programlisting>
<programlisting condition="PYTHON">
# 
# Returns the current flux of the reaction.
# 
FLUX=getFlux()

# 
# Returns the current flux of the reaction in terms 
# of particle numbers rather than concentrations
# 
PARTICLE_FLUX=getParticleFlux()

# 
# If the reaction is reversible, this returns True, else False.
# 
IS_REVERSIBLE=isReversible()

# 
# Sets whether the reaction is reversible or not.
# Arguments can be True or False
# 
setReversible(REVERSIBLE_FLAG)

# 
# Returns the number of compartments that are involved
# in this reaction.
# 
COMPARTMENT_NUMBER=getCompartmentNumber()

# 
# Returns the SBML id of the reaction if one has been set,
# otherwise an empty string is returned.
# 
ID_STRING=getSBMLId()

# 
# Sets the SBML id of the reaction.
# This is done during import of an SBML model, or
# during the first export of an SBML model.
# If you change the SBML id of any entity, further 
# exports to SBML might fail.
# 
setSBMLId(ID_STRING)

# 
# Returns the chemical equation object of the reaction.
# 
CHEMICAL_EQUATION=getChemEq()

# 
# Returns the function for the kinetic law used in the reaction.
# 
FUNCTION=getFunction()

# 
# Sets the kinetic law of the reaction via a functions name.
# A function with that name must exist in the function database.
# 
SUCCESS=setFunction(FUNCTION_NAME_STRING)
</programlisting>
</para>

<para>
The <emphasis>getFunction</emphasis> method returns the function that is used as the kinetic law. In COPASI all kinetic laws are determined by function calls. Using an expression as a kinetic law is not supported. All kinetic law expressions that are imported from SBML files are first converted to function definitions with a call to that function as the kinetic law. When those models are reexported, all expressions are exported as function calls.
There are exceptions to this rule however. If COPASI determines that a given rate law is a Mass Action rate law, no function definition is created but the Mass Action function build into COPASI is used as the kinetic law. On reexport to SBML, the kinetic law is converted to a Mass Action expression again. In the future, similar procedures might be used for other function types as for example constant flux.
</para>

<para>
The chemical equation of a reaction is stored in a <emphasis>CChemEq</emphasis> object which can be acquired from the reaction with a call to <emphasis>getChemEq</emphasis>.
The chemical equation object has several methods to query the properties of the chemical equation:
</para>

<para>
<programlisting condition="JAVA">
/**
 * Returns true if the chemical reaction is reversible.
 */
public boolean getReversibility();

/**
 * Sets whether the given chemical equation is to be reversible.
 */
public void setReversibility(boolean revers);

/**
 * Adds a new metabolite to the chemical equation.
 * key is the key of the metabolite 
 * (keys are the ids of COPASI objects)
 * mult is the stoichiometric coefficient
 * role is the role of the metabolite and it can be either
 * CChemEq.PRODUCT, CChemEq.SUBSTRATE, CChemEq.MODIFIER 
 * or CChemEq.NOROLE.
 */
public boolean addMetabolite(String key, double mult, int role);

/**
 * Gets a container with all the substrates of the 
 * chemical equation.
 * The size of the container can be queried with
 * its size method,
 * the element with index i can be retrieved with the
 * get method which takes the index as the only argument.
 */
public CChemEqElementVector getSubstrates();

/**
 * Gets a container with all the products of the 
 * chemical equation.
 * The size of the container can be queried with 
 * its size method,
 * the element with index i can be retrieved with the
 * get method which takes the index as the only argument.
 */
public CChemEqElementVector getProducts();

/**
 * Gets a container with all the modifiers of the
 * chemical equation.
 * The size of the container can be queried with its
 * size method,
 * the element with index i can be retrieved with the 
 * get method which takes the index as the only argument.
 */
public CChemEqElementVector getModifiers();

/**
 * Returns the number of compartments that are 
 * involved in this reaction.
 * If all metabolites that are involved in the
 * reaction are in the same compartment 1 is returned.
 */
public long getCompartmentNumber();

/**
 * Returns the largest compartment involved in the reaction.
 * This method should only be called after all transient values have been set,
 * otherwise an exception can occur. 
 * Maybe call applyInitialValues on the model before using this method.
 */
public CCompartment getLargestCompartment();

/**
 * Returns a CChemEqElement that represents the substrate
 * with the given index.
 */
public CChemEqElement getSubstrate(long index);

/**
 * Returns a CChemEqElement that represents the product
 * with the given index.
 */
public CChemEqElement getProduct(long index);

/**
 * Returns a CChemEqElement that represents the modifier
 * with the given index.
 */
public CChemEqElement getModifier(long index);
</programlisting>
<programlisting condition="CPP">
/**
 * Returns true if the chemical reaction is reversible.
 */
const bool&amp; getReversibility() const;

/**
 * Sets whether the given chemical equation is to be reversible.
 */
void setReversibility(const bool&amp; revers);

/**
 * Adds a new metabolite to the chemical equation.
 * key is the key of the metabolite 
 * (keys are the ids of COPASI objects)
 * mult is the stoichiometric coefficient
 * role is the role of the metabolite and it can be either
 * CChemEq::PRODUCT, CChemEq::SUBSTRATE, CChemEq::MODIFIER 
 * or CChemEq::NOROLE.
bool addMetabolite(const std::string&amp; key, const C_FLOAT64 multiplicity, const MetaboliteRole&amp; role);

/**
 * Gets a container with all the substrates of the 
 * chemical equation.
 * The size of the container can be queried with
 * its size method,
 * the element with index i can be retrieved with the
 * get method which takes the index as the only argument.
 */
const CCopasiVector&lt;CChemEqElement&gt;amp; getSubstrates() const;

/**
 * Gets a container with all the products of the 
 * chemical equation.
 * The size of the container can be queried with 
 * its size method,
 * the element with index i can be retrieved with the
 * get method which takes the index as the only argument.
 */
const CCopasiVector&lt;CChemEqElement&gt;amp; getProducts() cosnt;

/**
 * Gets a container with all the modifiers of the
 * chemical equation.
 * The size of the container can be queried with its
 * size method,
 * the element with index i can be retrieved with the 
 * get method which takes the index as the only argument.
 */
const CCopasiVector&lt;CChemEqElement&gt;amp; getModifiers() const;

/**
 * Returns the number of compartments that are 
 * involved in this reaction.
 * If all metabolites that are involved in the
 * reaction are in the same compartment 1 is returned.
 */
unsigned C_INT32 getCompartmentNumber() const;

/**
 * Returns the largest compartment involved in the reaction.
 * This method should only be called after all transient values have been set,
 * otherwise an exception can occur. 
 * Maybe call applyInitialValues on the model before using this method.
 */
const CCompartment* getLargestCompartment() const;
</programlisting>
<programlisting condition="PYTHON">
# 
# Returns true if the chemical reaction is reversible.
# 
REVERSIBLE=getReversibility()

# 
# Sets whether the given chemical equation is to be reversible.
# 
setReversibility(REVERSIBLE_FLAG)

# 
# Adds a new metabolite to the chemical equation.
# key is the key of the metabolite 
# (keys are the ids of COPASI objects)
# mult is the stoichiometric coefficient
# role is the role of the metabolite and it can be either
# CChemEq.PRODUCT, CChemEq.SUBSTRATE, CChemEq.MODIFIER 
# or CChemEq.NOROLE.
SUCCESS=addMetabolite(METABOLITE_KEY_STRING, STOICHIOMETRY, ROLE)

# 
# Gets a container with all the substrates of the 
# chemical equation.
# The size of the container can be queried with
# its size method,
# the element with index i can be retrieved with the
# get method which takes the index as the only argument.
# 
ELEMENT_VECTOR=getSubstrates()

# 
# Gets a container with all the products of the 
# chemical equation.
# The size of the container can be queried with 
# its size method,
# the element with index i can be retrieved with the
# get method which takes the index as the only argument.
# 
ELEMENT_VECTOR=getProducts()

# 
# Gets a container with all the modifiers of the
# chemical equation.
# The size of the container can be queried with its
# size method,
# the element with index i can be retrieved with the 
# get method which takes the index as the only argument.
# 
ELEMENT_VECTOR=getModifiers()

# 
# Returns the number of compartments that are 
# involved in this reaction.
# If all metabolites that are involved in the
# reaction are in the same compartment 1 is returned.
# 
COMPARTMENT_NUMBER=getCompartmentNumber()

# 
# Returns the largest compartment involved in the reaction.
# This method should only be called after all transient values have been set,
# otherwise an exception can occur. 
# Maybe call applyInitialValues on the model before using this method.
# 
COMPARTMENT=getLargestCompartment()

# 
# Returns a CChemEqElement that represents the substrate
# with the given index.
# 
CHEMICAL_EQUATION_ELEMENT=getSubstrate(INDEX)

# 
# Returns a CChemEqElement that represents the product
# with the given index.
# 
CHEMICAL_EQUATION_ELEMENT=getProduct(INDEX)

# 
# Returns a CChemEqElement that represents the modifier
# with the given index.
# 
CHEMICAL_EQUATION_ELEMENT=getModifier(INDEX)
</programlisting>
</para>

<para>
The individual entities of the chemical reaction (substrates, products and modifiers) are
represented by <emphasis>CChemEqElement</emphasis> instances. A <emphasis>CChemEqElement</emphasis> object stores the stoichiometric coefficient of the reaction entity  and the key of the associated <emphasis>CMetab</emphasis> object. Those properties can be queried and manipulated with the following methods:
</para>

<para>
<programlisting condition="JAVA">
/**
 * Returns the stoichiometric coefficient of the element.
 */
public double getMultiplicity();

/**
 * Sets the stoichiometric coefficient of the element.
 */
public void setMultiplicity(double multiplicity);

/**
 * Returns the associated CMetab instance.
 */
public CMetab getMetabolite();

/**
 * Returns the key of the associated CMetab instance.
 */
public String getMetaboliteKey();

/**
 * Sets the associated CMetab instance via its key.
 */
public void setMetabolite(String key);
</programlisting>
<programlisting condition="CPP">
/**
 * Returns the stoichiometric coefficient of the element.
 */
C_FLOAT64 getMultiplicity() const;

/**
 * Sets the stoichiometric coefficient of the element.
 */
void setMultiplicity(const C_FLOAT64 multiplicity);

/**
 * Returns the associated CMetab instance.
 */
const CMetab* getMetabolite() const;

/**
 * Returns the key of the associated CMetab instance.
 */
const std::string&amp; getMetaboliteKey() const;

/**
 * Sets the associated CMetab instance via its key.
 */
void setMetabolite(const std::string&amp; key);
</programlisting>
<programlisting condition="PYTHON">
# 
# Returns the stoichiometric coefficient of the element.
# 
STOICHIOMETRY=getMultiplicity()

# 
# Sets the stoichiometric coefficient of the element.
# 
setMultiplicity(STOICHIOMETRY)

# 
# Returns the associated CMetab instance.
# 
METABOLITE=getMetabolite()

# 
# Returns the key of the associated CMetab instance.
# 
METABOLITE_KEY_STRING=getMetaboliteKey()

# 
# Sets the associated CMetab instance via its key.
# 
setMetabolite(METABOLITE_KEY_STRING)
</programlisting>
</para>
</sect3>
<sect3 id="events" xreflabel="events">
<title>events</title>

<para>
The class for events is called <emphasis>CEvent</emphasis>. It contains information on the condition that determines when an event is triggered, the assignments that are executed when the event is triggered and an optional delay expression that determines how long after the actual triggering of the event, the assignments are applied. 
</para>

<para>
<programlisting condition="CPP">
/**
 * Set the order in which the event is executed for simultaneous events.
 * @param const unsigned C_INT32 &amp; order
 * const bool &amp; correctOther = true
 */
void setOrder(const unsigned C_INT32 &amp; order, const bool &amp; correctOther = true);

/**
 * Retrieve the order in which the event is executed for simultaneous events
 */
const unsigned C_INT32 &amp; getOrder() const;

/**
 * Sets the SBMLId of the event.
 * @param const std::string &amp; id
 */
void setSBMLId(const std::string &amp; id);

/**
 * Returns a reference to the SBML Id of the event.
 */
const std::string&amp; getSBMLId() const;

/**
 * Set whether the calculation or the assignments shall be delayed
 */
void setDelayAssignment(const bool &amp; delayCalculation);

/**
 * Retrieve whether to delay the calculation of the assignments.
 * @return const bool &amp; delayCalculation
 */
const bool &amp; getDelayAssignment() const;

/**
 * Set the expression of trigger from a string. The return value indicates if
 * parsing the expression was successful.
 * @param const std::string &amp; expression
 * @return bool success
 */
bool setTriggerExpression(const std::string &amp; expression);

/**
 * Set the expression of trigger from a CExpression instance.
 * The pointer is owned by the event after it has been set.
 * @param CExpression* pExpression
 */
void setTriggerExpressionPtr(CExpression * pExpression);

/**
 * Retrieve the expression of trigger as a string.
 * @return std::string expression
 */
std::string getTriggerExpression() const;

/**
 * Retrieve the const pointer to the trigger expression.
 * @return const CExpression* pExpression
 */
const CExpression * getTriggerExpressionPtr() const;

/**
 * Retrieve the pointer to the trigger expression.
 * @return CExpression* pExpression
 */
CExpression * getTriggerExpressionPtr();

/**
 * Set the expression of delay from a string. The return value indicates if
 * parsing the expression was successful.
 * @param const std::string &amp; expression
 * @return bool success
 */
bool setDelayExpression(const std::string &amp; expression);

/**
 * Set the expression of delay from a CExpression instance pointer.
 * The pointer is owned by the event after it has been set.
 * @param CExpression* pExpression
 */
void setDelayExpressionPtr(CExpression* pExpression);

/**
 * Retrieve the expression of the delay expression as a string.
 * @return std::string expression
 */
std::string getDelayExpression() const;

/**
 * Retrieve the pointer to the expression of the delay.
 * @return CExpression* pExpression
 */
CExpression* getDelayExpressionPtr();

/**
 * Retrieve the const pointer to the expression of the delay.
 * @return const CExpression* pExpression
 */
const CExpression* getDelayExpressionPtr() const;

/**
 * Retrieve the assignments. This will return a const reference to the CCopasiVectorN which holds the assignments for the event.
 * @return const CCopasiVectorN&lt; CEventAssignment &gt; &amp; assignments
 */
const CCopasiVectorN&lt; CEventAssignment &gt; &amp; getAssignments() const;

/**
 * Retrieve the assignments. This will return the reference to the CCopasiVectorN which holds all the assignments.
 * @return CCopasiVectorN&lt; CEventAssignment &gt; &amp; assignments
 */
CCopasiVectorN&lt; CEventAssignment &gt; &amp; getAssignments();

/**
 * Delete assignment with the given key. Please note this is not the target key.
 * @param const std::string &amp; key
 */
void deleteAssignment(const std::string &amp; key);
</programlisting>
<programlisting condition="JAVA">
/**
 * Set the order in which the event is executed for simultaneous events.
 * @param long order
 * @param boolean correctOther
 */
void setOrder(long order, boolean correctOther);

/**
 * Retrieve the order in which the event is executed for simultaneous events
 */
long getOrder() const;

/**
 * Sets the SBMLId of the event.
 * @param const String id
 */
void setSBMLId(const String id);

/**
 * Returns a the SBML Id of the event.
 */
const String getSBMLId() const;

/**
 * Set whether the calculation or the assignments shall be delayed
 */
void setDelayAssignment(boolean delayCalculation);

/**
 * Retrieve whether to delay the calculation of the assignments.
 * @return boolean delayCalculation
 */
boolean getDelayAssignment() const;

/**
 * Set the expression of trigger from a string. The return value indicates if
 * parsing the expression was successful.
 * @param const String expression
 * @return boolean success
 */
boolean setTriggerExpression(const String expression);

/**
 * Set the expression of trigger from a CExpression instance.
 * The expression is owned by the event after it has been set.
 * @param CExpression expression
 */
void setTriggerExpressionPtr(CExpression expression);

/**
 * Retrieve the expression of trigger as a string.
 * @return String expression
 */
String getTriggerExpression() const;

/**
 * Retrieve the trigger expression object.
 * @return CExpression expression
 */
CExpression getTriggerExpressionPtr();

/**
 * Set the expression of delay from a string. The return value indicates if
 * parsing the expression was successful.
 * @param const String expression
 * @return boolean success
 */
boolean setDelayExpression(const String expression);

/**
 * Set the expression of delay from a CExpression instance.
 * The expression is owned by the event after it has been set.
 * @param CExpression expression
 */
void setDelayExpressionPtr(CExpression expression);

/**
 * Retrieve the expression of the delay expression as a string.
 * @return String expression
 */
String getDelayExpression() const;

/**
 * Retrieve the expression of the delay.
 * @return CExpression expression
 */
CExpression getDelayExpressionPtr();

/**
 * Retrieve the assignments. This will return the EventAssignmentVectorN which holds the assignments for the event.
 * @return EventAssignmentVectorN assignments
 */
EventAssignmentVectorN getAssignments();

/**
 * Delete assignment with the given key. Please note this is not the target key.
 * @param const String key
 */
void deleteAssignment(const String key);
</programlisting>
<programlisting condition="Python">
#  
#  Set the order in which the event is executed for simultaneous events.
#  @param integer order
#  @param boolean correctOther
#  
setOrder(order, correctOther)

#  
#  Retrieve the order in which the event is executed for simultaneous events
#  
order=getOrder()

#  
#  Sets the SBMLId of the event.
#  @param id string
#  
setSBMLId(id)

#  
#  Returns a the SBML Id of the event.
#  
id=getSBMLId()

#  
#  Set whether the calculation or the assignments shall be delayed
#  
setDelayAssignment(delayCalculationFlag)

#  
#  Retrieve whether to delay the calculation of the assignments.
#  @return boolean delayCalculation
#  
delayAssignmentFlag=getDelayAssignment()

#  
#  Set the expression of trigger from a string. The return value indicates if
#  parsing the expression was successful.
#  @param const String expression
#  @return boolean success
#  
result=setTriggerExpression(expressionString)

#  
#  Set the expression of trigger from a CExpression instance.
#  The expression is owned by the event after it has been set.
#  @param CExpression expression
#  
setTriggerExpressionPtr(expressionObject)

#  
#  Retrieve the expression of trigger as a string.
#  @return String expression
#  
expressionString=getTriggerExpression()

#  
#  Retrieve the trigger expression object.
#  @return CExpression expression
#  
expressionObject=getTriggerExpressionPtr()

#  
#  Set the expression of delay from a string. The return value indicates if
#  parsing the expression was successful.
#  @param const String expression
#  @return boolean success
#  
result=setDelayExpression(expressionString)

#  
#  Set the expression of delay from a CExpression instance.
#  The expression is owned by the event after it has been set.
#  @param CExpression expression
#  
setDelayExpressionPtr(expressionObject)

#  
#  Retrieve the expression of the delay expression as a string.
#  @return String expression
#  
delayExpressionString=getDelayExpression()

#  
#  Retrieve the expression of the delay.
#  @return CExpression expression
#  
expression=getDelayExpressionPtr()

#  
#  Retrieve the assignments. This will return the EventAssignmentVectorN which holds the assignments for the event.
#  @return EventAssignmentVectorN assignments
#  
eventassignments=getAssignments()

#  
#  Delete assignment with the given key. Please note this is not the target key.
#  @param String key
#  
deleteAssignment(keyString)
</programlisting>

The individual assignments that have to be executed when an event fires are represented by the CEventAssignment class in COPASI.
Each event assignment has a target which is the object that is changed and an expression that determines the value to which the target is set.

<programlisting condition="CPP">
/**
 * Set the key of the target
 * @param const std::string &amp; targetKey
 * @return bool success;
 */
bool setTargetKey(const std::string &amp; targetKey);

/**
 * Retrieve the target key
 * @return const std::string &amp; targetKey
 */
const std::string &amp; getTargetKey() const;

/**
 * Retrieve a pointer to the target object.
 * @return const CCopasiObject * targetObject
 */
const CCopasiObject * getTargetObject() const;

/**
 * Set the expression from an infix string. The return value indicates if
 * parsing the expression was successful.
 * @param const std::string &amp; expression
 * @return bool success
 */
bool setExpression(const std::string &amp; expression);

/**
 * Set the expression from an expression pointer. CEventAssignment takes ownership.
 * @param CExpression* pExpression
 */
void setExpressionPtr(CExpression * pExpression);

/**
 * Retrieve the expression as a string.
 * @return std::string expression
 */
std::string getExpression() const;

/**
 * Retrieve the pointer to the expression.
 * @return CExpression * pExpression
 */
const CExpression * getExpressionPtr() const;

/**
 * Retrieve the pointer to the expression.
 * @return CExpression * pExpression
 */
CExpression * getExpressionPtr();
</programlisting>
<programlisting condition="Java">
/**
 * Set the key of the target
 * @param const String targetKey
 * @return boolean success;
 */
boolean setTargetKey(const String targetKey);

/**
 * Retrieve the target key
 * @return const String targetKey
 */
const String getTargetKey() const;

/**
 * Retrieve the target object.
 * @return const CCopasiObject targetObject
 */
const CCopasiObject getTargetObject() const;

/**
 * Set the expression from an infix string. The return value indicates if
 * parsing the expression was successful.
 * @param const String expression
 * @return boolean success
 */
boolean setExpression(const String expression);

/**
 * Set the expression from an expression object. CEventAssignment takes ownership.
 * @param CExpression expression
 */
void setExpressionPtr(CExpression expression);

/**
 * Retrieve the expression as a string.
 * @return String expression
 */
String getExpression() const;

/**
 * Retrieve the expression object.
 * @return CExpression expression
 */
CExpression getExpressionPtr();
</programlisting>
<programlisting condition="Python">
#  
#  Set the key of the target
#  @param targetKey string
#  @return boolean success;
#  
result=setTargetKey(targetKeyString)

#  
#  Retrieve the target key
#  @return targetKey
#  
targetKeyString=getTargetKey()

#  
#  Retrieve the target object.
#  @return const CCopasiObject targetObject
#  
targetObject=getTargetObject()

#  
#  Set the expression from an infix string. The return value indicates if
#  parsing the expression was successful.
#  @param expressionString
#  @return boolean success
#  
result=setExpression(expressionString)

#  
#  Set the expression from an expression object. CEventAssignment takes ownership.
#  @param CExpression expressionObject
#  
setExpressionPtr(expressionObject)

#  
#  Retrieve the expression as a string.
#  @return expressionString
#  
expressionString=getExpression()

#  
#  Retrieve the expression object
#  @return CExpression expressionObject
#  
expressionObject=getExpressionPtr()
</programlisting>
</para>
</sect3>
</sect2>

<sect2 id="functionDatabase" xreflabel="functionDatabase">
<title>The Function Database</title>

<para>
The function database is the place where COPASI stores all function definitions, that is all builtin functions as well as all used defined functions. There is only one global function database and it is not associated with the current model. If the model is deleted, all functions that were used in the model stay in the function database.
</para>

<para>
The function database object is an instance of the class <emphasis>CFunctionDB</emphasis> and the global function database can be acquire from the root container:
</para>

<para>
<programlisting condition="JAVA">
CFunctionDB funDB=CCopasiRootContainer.getFunctionList();
</programlisting>
<programlisting condition="CPP">
CFunctionDB* funDB=CCopasiRootContainer::getFunctionList();
</programlisting>
<programlisting condition="PYTHON">
funDB=CCopasiRootContainer.getFunctionList()
</programlisting>
</para>

<para>
The <emphasis>CFunctionDB</emphasis> class has a number of methods to get, remove or add new function definitions.
</para>

<para>
<programlisting condition="JAVA">
/**
 * Finds the function with the given name.
 * If no function with this name can be found, null is returned.
 */
public CEvaluationTree findFunction(String functionName);

/**
 * Returns a container with all known function definitions.
 * The size of the container can be queries with the size 
 * method and individual elements of type CEvaluationTree 
 * can be acquire with the get method. The only argument to
 * the get method is the index of the desired function.
 */  
public CEvaluationTreeVectorN loadedFunctions();

/**
 * Returns a container with all functions that are suitable
 * for the given number of substrates and products and the 
 * given reversibility.
 * noSubstrates: desired number of substrates
 * noProducts: desired number of products
 * reversibility: whether the function should be suitable for
 * reversible or irreversible reactions.
 */  
public CFunctionStdVector suitableFunctions(long noSubstrates, 
                               long noProducts, int reversibility);

/**
 * Removes the function definition with the given key.
 */
public boolean removeFunction(String key);


/**
 * Removes all functions from the function database.
 * You should only call this method if you do not have a model loaded 
 * that uses the functions.
 */
public void cleanup();

/**
 * Loads the builtin functions into the function database.
 * Calling this after calling cleanup will basically reinstantiate 
 * the function database.
 */
public void load(); 

/**
 * Creates a new CFunction object with the given name and type.
 * You have to make sure the function name is unique.
 * The created function is owned by the COPASI backend and is not deleted 
 * by the Java garbage collector as is the case if the function is created via 
 * the constructor and added to the funciton database with the add method.
 *
 * The type argument is one of the types defined int the CEvaluationTree class.
 * For user defined functions, this is usually CEvaluationTree.UserDefined.
 */
public CFunction createFunction(String name,int type);
</programlisting>
<programlisting condition="CPP">
/**
 * Finds the function with the given name.
 * If no function with this name can be found, NULL is returned.
 */
CEvaluationTree* findFunction(const std::string&amp; functionName);

/**
 * Returns a container with all known function definitions.
 * The size of the container can be queries with the size 
 * method and individual elements of type CEvaluationTree 
 * can be acquire with the get method. The only argument to
 * the get method is the index of the desired function.
 */  
CCopasiVectorN&lt;CEvaluationTree&lt;amp; loadedFunctions();

/**
 * Returns a container with all functions that are suitable
 * for the given number of substrates and products and the 
 * given reversibility.
 * noSubstrates: desired number of substrates
 * noProducts: desired number of products
 * reversibility: whether the function should be suitable for
 * reversible or irreversible reactions.
 */  
std::vector&lt;CFunction*&gt; suitableFunctions(const unsigned C_INT32 noSubstrates, 
                               const unsigned C_INT32 noProducts, const TriLogic reversibility);

/**
 * Removes the function definition with the given key.
 */
bool removeFunction(const std::string&amp; key);

/**
 * Removes all functions from the function database.
 * You should only call this method if you do not have a model loaded 
 * that uses the functions.
 */
void cleanup();

/**
 * Loads the builtin functions into the function database.
 * Calling this after calling cleanup will basically reinstantiate 
 * the function database.
 */
void load(); 

/**
 * Adds the given function to the COPASI function database.
 * The second argument determines whether COPASI will take ownership 
 * of the function or if ownership remains with the calling program.
 * If the second argument is specified as false, the programmer is
 * responsible for eventually deleting the function object.
 *
 * The return value indicates whether adding the function was successfull 
 * or not.
 */
bool add(CFunction* pFunction, bool adopt); 
</programlisting>
<programlisting condition="PYTHON">
# 
# Finds the function with the given name.
# If no function with this name can be found, null is returned.
# 
FUNCTION=findFunction(FUNCTION_NAME_STRING)

# 
# Returns a container with all known function definitions.
# The size of the container can be queries with the size 
# method and individual elements of type CEvaluationTree 
# can be acquire with the get method. The only argument to
# the get method is the index of the desired function.
#   
FUNCTION_VECTOR=loadedFunctions()

# 
# Returns a container with all functions that are suitable
# for the given number of substrates and products and the 
# given reversibility.
# NUMBER_OF_SUBSTRATES: desired number of substrates
# NUMBER_OF_PRODUCTS: desired number of products
# reversibility: whether the function should be suitable for
# reversible or irreversible reactions (TriTrue, TriFalse or TriUnspecified.
#   
FUNCTION_VECTOR=suitableFunctions(NUMBER_OF_SUBSTRATES, 
                               NUMBER_OF_PRODUCTS, REVERSIBILITY_FLAG)

# 
# Removes the function definition with the given key.
# 
SUCCESS=removeFunction(FUNCTION_KEY_STRING)

#
# Removes all functions from the function database.
#  You should only call this method if you do not have a model loaded 
#  that uses the functions.
#
cleanup()

#  
#  Loads the builtin functions into the function database.
#  Calling this after calling cleanup will basically reinstantiate 
#  the function database.
#  
load() 

/**
 * Creates a new CFunction object with the given name and type.
 * You have to make sure the function name is unique.
 *
 * The type argument is one of the types defined int the CEvaluationTree class.
 * For user defined functions, this is usually CEvaluationTree.UserDefined.
 */
FUNCTION=createFunction(name,type);
</programlisting>
</para>
<para>
<caution>Since COPASI uses only a single function database, this database will keep growing as you load or import models. As one of our users noticed, this will eventually lead to a severe slowdown while importing SBML models. In order to get around this problem, you can restore the function database to it's initial state once in a while by calling cleanup and then load on the function database object. However, you should only do this while there is no model loaded that uses these functions. So it is best to first remove all instances of <emphasis>CCopasiDataModel</emphasis> (see removeDataModel from <emphasis>CCopasiRootContainer</emphasis>).</caution>
</para>

<para>
The individual function definitions are instances of the class <emphasis>CEvaluationTree</emphasis> or of subclasses of that class, e.g. <emphasis>CFunction</emphasis>.
COPASI distinguishes between different types of function definitions:
</para>

<para>
<variablelist condition="JAVA">
<varlistentry>
<term>CEvaluationTree.MassAction</term>
<listitem><para>this is the type of the mass action kinetic function definition</para></listitem>
</varlistentry>
<varlistentry>
<term>CEvaluationTree.PreDefined</term>
<listitem><para>this type is set on all builtin function definitions that are not mass action</para></listitem>
</varlistentry>
<varlistentry>
<term>CEvaluationTree.UserDefined</term>
<listitem><para>this type is set on all user defined function definitions</para></listitem>
</varlistentry>
</variablelist>
<variablelist condition="CPP">
<varlistentry>
<term>CEvaluationTree::MassAction</term>
<listitem><para>this is the type of the mass action kinetic function definition</para></listitem>
</varlistentry>
<varlistentry>
<term>CEvaluationTree::PreDefined</term>
<listitem><para>this type is set on all builtin function definitions that are not mass action</para></listitem>
</varlistentry>
<varlistentry>
<term>CEvaluationTree::UserDefined</term>
<listitem><para>this type is set on all user defined function definitions</para></listitem>
</varlistentry>
</variablelist>
<variablelist condition="PYTHON">
<varlistentry>
<term>CEvaluationTree.MassAction</term>
<listitem><para>this is the type of the mass action kinetic function definition</para></listitem>
</varlistentry>
<varlistentry>
<term>CEvaluationTree.PreDefined</term>
<listitem><para>this type is set on all builtin function definitions that are not mass action</para></listitem>
</varlistentry>
<varlistentry>
<term>CEvaluationTree.UserDefined</term>
<listitem><para>this type is set on all user defined function definitions</para></listitem>
</varlistentry>
</variablelist>
</para>

<para>
The type of a <emphasis>CEvaluationTree</emphasis> object can be queried with the <emphasis>getType</emphasis> method. 
The formula that is associated with a function definition can be queried with the <emphasis>getInfix</emphasis> method. This method returns the equation as a ASCII string. In order to set the equation one can use the <emphasis>setInfix</emphasis> method. This method takes the formula as an ASCII string and returns <emphasis>true</emphasis> if the equation has been set successfully. If there was an error, the method returns <emphasis>false</emphasis>. 
</para>

<para>
Besides the mass action function definition which is an instance if the class <emphasis>CMassAction</emphasis> (for which there are currently no wrapper functions) all function definitions are instances of <emphasis>CFunction</emphasis>. In addition to the method from its base class <emphasis>CEvaluationTree</emphasis>, <emphasis>CFunction</emphasis> has some additional methods to handle the function parameters and some other properties.
</para>

<para>
<programlisting condition="JAVA">
/**
 * If the reaction is reversible, the return value
 * COPASIConstants.TriTrue,
 * if the reaction is not reversible it is
 * COPASIConstants.TriFalse.
 * If the function is not meant to be used as a kinetic law,
 * the result might  also be COPASIConstants.TriUnspecified.
 */
public int isReversible();

/**
 * Sets whether the function is meant to be used on reversible
 * reaction, irreversible reactions, or if it is a general function
 * not meant to be used as a kinetic law.
 * The allowed values are COPASIConstants.TriTrue, COPASIConstants.
 * TriFalse or COPASIConstants.TriUnspecified, respectively.
 */
public void setReversible(int reversible);

/**
 * Returns a CFunctionParameters structure that holds
 * all parameters for the function definition.
 */
public CFunctionParameters getVariables();

/**
 * Returns the index of the variable with the given name.
 * If there is no function parameter with that name, 
 * -1 is returned.
 */
public long getVariableIndex(String name);

/**
 * Returns true if the function definition is suitable for the
 * given number of substrates, products and the given reversibility.
 */
public boolean isSuitable(long noSubstrates, long noProducts,
                          int reversible);
</programlisting>
<programlisting condition="CPP">
/**
 * If the reaction is reversible, the return value
 * TriTrue,
 * if the reaction is not reversible it is
 * TriFalse.
 * If the function is not meant to be used as a kinetic law,
 * the result might  also be TriUnspecified.
 */
const TriLogic&amp; isReversible() const;

/**
 * Sets whether the function is meant to be used on reversible
 * reaction, irreversible reactions, or if it is a general function
 * not meant to be used as a kinetic law.
 * The allowed values are TriTrue, 
 * TriFalse or TriUnspecified, respectively.
 */
void setReversible(const TriLogic&amp; reversible);

/**
 * Returns a CFunctionParameters structure that holds
 * all parameters for the function definition.
 */
CFunctionParameters&amp; getVariables();
const CFunctionParameters&amp; getVariables() const;

/**
 * Returns the index of the variable with the given name.
 * If there is no function parameter with that name, 
 * -1 is returned.
 */
unsigned C_INT32 getVariableIndex(const std::string&amp; name) const;

/**
 * Returns true if the function definition is suitable for the
 * given number of substrates, products and the given reversibility.
 */
bool isSuitable(const unsigned C_INT32 noSubstrates, const unsigned C_INT32 noProducts,
                          const TriLogic reversible);
</programlisting>
<programlisting condition="PYTHON">
# 
# If the reaction is reversible, the return value
# TriTrue,
# if the reaction is not reversible it is
# TriFalse.
# If the function is not meant to be used as a kinetic law,
# the result might  also be TriUnspecified.
# 
REVERSIBILITY_FLAG=isReversible()

# 
# Sets whether the function is meant to be used on reversible
# reaction, irreversible reactions, or if it is a general function
# not meant to be used as a kinetic law.
# The allowed values are TriTrue, 
# TriFalse or TriUnspecified, respectively.
# 
setReversible(REVERSIBILITY_FLAG)

# 
# Returns a CFunctionParameters structure that holds
# all parameters for the function definition.
# 
FUNCTION_PARAMETERS=getVariables()

# 
# Returns the index of the variable with the given name.
# If there is no function parameter with that name, 
# -1 is returned.
# 
INDEX=getVariableIndex(VARIABLE_NAME_STRING)

# 
# Returns true if the function definition is suitable for the
# given number of substrates, products and the given reversibility.
# 
SUITABLE=isSuitable(NUM_SUBSTRATS, NUM_PRODUCTS, REVERSIBILITY_FLAG)
                          
</programlisting>
</para>

<para>
When the equation is set for a function definition, the parameters are parsed and added to the function definition.
</para>
</sect2>


<sect2 id="initialValues" xreflabel="initialValues">
<title>Setting initial values on model entities</title>

<para>
It is not obvious what consequences it has when the initial values of model entities are changed because changing the initial value of a model entity might influence other initial values, e.g. compartment volumes influence the concentration of the contained metabolites.
Therefore, it is not enough to just set the initial values on model entities, but it is necessary to tell COPASI which objects have been changed so that COPASI can update dependent values.
This update is executed with the <emphasis>updateInitialValues</emphasis> method of <emphasis>CModel</emphasis>. The method takes one argument which is a container that stores all initial values that have been changed in the model. The container is an instance of <emphasis>ObjectStdVector</emphasis> and store objects of type <emphasis>CCopasiObject</emphasis>. The objects stored there are the actual values that have been changed, not the model entities the values belong to, e.g. if the initial concentration of a metabolite has been changed, an object representing this initial concentration can be acquire by calling <emphasis>getObject</emphasis> on the model entity with a <emphasis>CCopasiObjectName</emphasis> as the argument that specifies what value to get.
So assuming <emphasis>container</emphasis> is an instance of <emphasis>ObjectStdVector</emphasis> and <emphasis>metab</emphasis> is an instance of <emphasis>CMetab</emphasis> and the initial concentration of <emphasis>metab</emphasis> has been changed, we can add the object that corresponds to the initial concentration of <emphasis>metab</emphasis> with
</para>

<para>
<programlisting condition="JAVA">
container.add(metab.getObject(new CCopasiObjectName("Reference=InitialConcentration")));
</programlisting>
<programlisting condition="CPP">
pContainer->add(pMetab->getObject(CCopasiObjectName("Reference=InitialConcentration")));
</programlisting>
<programlisting condition="PYTHON">
container.push_back(metab.getObject(CCopasiObjectName("Reference=InitialConcentration")))
</programlisting>
</para>

<para>
The same procedure can be used for the initial volume of compartments, he initial value of parameters and the value of local reaction parameters. The respective strings to initialize the CCopasiObjectName instance are <screen>"Reference=InitialVolume"</screen>, <screen>"Reference=InitialValue"</screen> and <screen>"Reference=Value"</screen>.
Once all changed values have been added to the container, <emphasis>updateInitialValues</emphasis> can by called on the instance of <emphasis>CModel</emphasis> with the container as the only argument. 
</para>
</sect2>
</sect1>

<sect1 id="tasks" xreflabel="tasks">
<title>Working with Tasks</title>
<sect2 id="task_problem_method" xreflabel="task_problem_method">
<title>The Task-Problem-Method Concept in COPASI</title>

<para>
In COPASI calculations you can do on the current model are represented by so called tasks. The base class for all tasks is <emphasis>CCopasiTask</emphasis>. Each task contains a problem represented by a subclass of <emphasis>CCopasiProblem</emphasis> and a method represented by a subclass of <emphasis>CCopasiMethod</emphasis>.
For a given task type, e.g. time course simulation, there is one task class, one problem class and one or more method classes. The problem of a task describes what is going to be done when the task is run and the method describes how it is done.
Lets make this a little more clear by looking at the task class for running time course simulations on a model. The task class for this is <emphasis>CTrajectoryTask</emphasis> and is contains an instance of the problem class <emphasis>CTrajectoryProblem</emphasis>. The problem for the time course simulation stores the parameters for the simulation like start time, end time and number of steps. The method class for the time course task is a subclass of <emphasis>CTrajectoryMethod</emphasis> which itself is a subclass of <emphasis>CCopasiMethod</emphasis>. At the time of writing, there were six method classes derived from <emphasis>CTrajectoryMethod</emphasis>. Two of the method classes are for deterministic simulation, two are for stochastic simulation and two are for hybrid simulation. Each of the methods contains parameters that are specific to the method and which can be changed to influence the corresponding method.
</para>

<para>
All tasks are stored in <emphasis>CCopasiDataModel</emphasis>. <emphasis>CCopasiDataModel</emphasis> provides the method <emphasis>getTaskList()</emphasis> to get the list of tasks. The returned object is of the type <emphasis>TaskVectorN</emphasis> and provides a method called <emphasis>size()</emphasis> to find out how many tasks it contains and a method <emphasis condition="JAVA">get(long index)</emphasis><emphasis condition="CPP">get(C_INT32 index)</emphasis><emphasis condition="PYTHON">get(INDEX)</emphasis> to retrieve the task with the given index. The object that is returned is of type <emphasis>CCopasiObject</emphasis>. Alternatively, <emphasis>CCopasiDataModel</emphasis> has a method called <emphasis condition="JAVA">getTask(long index)</emphasis><emphasis condition="CPP">getTask(C_INT32 index)</emphasis><emphasis condition="PYTHON">getTask(INDEX)</emphasis> which returns the <emphasis>CCopasiTask</emphasis> object with the given index. 
</para>

<para>
To get the problem and the method for a given task, <emphasis>CCopasiTask</emphasis> provides the methods <emphasis>getProblem()</emphasis> and <emphasis>getMethod()</emphasis> respectively and the objects returned are of type <emphasis>CCopasiProblem</emphasis> and <emphasis>CCopasiMethod</emphasis>. Normally there is no need to cast the task, problem or method objects to the most specific subclass since the base classes already provide all the needed functionality.
</para>

<para>
All that is needed to run any task is 
<orderedlist numeration="arabic">
<listitem><para>get the correct task from the instance of <emphasis>CCopasiDataModel</emphasis></para></listitem>
<listitem><para>if the task does not exist yet, create a new one and add it to the instance of <emphasis>CCopasiDataModel</emphasis></para></listitem>
<listitem><para>change the parameters of the problem if the default values are not O.K.</para></listitem>
<listitem><para>change the method for the task if the one set is not the one that is wanted</para></listitem>
<listitem><para>change the parameters on the method if the default values are not O.K.</para></listitem>
</orderedlist>
</para>

<para>
The procedure is (almost) the same no matter what the task might be, although some tasks might need some additional steps. What those additional steps are will be explained in the corresponding sections below.   
</para>

<para>
The first thing is to get the correct task. For this the type of the task has to be known. The type of a task is an integer value and a list of all known types can be found in CCopasiTask.java. Some of those tasks are not available from Java yet. If we look at this list, we see that the type for the time course simulation task is CCopasiTask.timeCourse. So in order to find the time course task, we write a loop that checks all tasks that the CCopasiDataModel instance knows if one has the correct type. For each task type, there can be at most one task.
</para>

<para>
So to find the time course simulation task we could use the following code:
</para>

<para>
<programlisting condition="JAVA">
<![CDATA[
long i=0;
long iMax=datamodel.getTaskList().size();
CTrajectoryTask task=null;
for(i=0;i<iMax;i++)
{
   if(datamodel.getTask(i).getType()==CCopasiTask.timeCourse)
   {
       task=datamodel.getTask(i);
       break;
   }
}
if(task==null)
{
   // create the task
   task=datamodel.addTask(CCopasiTask.timeCourse);
}]]>
</programlisting>
<programlisting condition="CPP">
<![CDATA[
long i=0;
long iMax=pDataModel->getTaskList()->size();
CTrajectoryTask* pTask=NULL;
for(i=0;i<iMax;i++)
{
   if((*pDataModel->getTaskList())[i]->getType()==CCopasiTask::timeCourse)
   {
       pTask=(*pDataModel->getTaskList())[i];
       break;
   }
}
if(pTask==NULL)
{
   // create the task
   pTask=pDataModel->addTask(CCopasiTask::timeCourse);
}]]>
</programlisting>
<programlisting condition="PYTHON">
<![CDATA[
iMax=datamodel.getTaskList().size()
task=None
for i in range(0,iMax):
   if datamodel.getTask(i).getType()==CCopasiTask.timeCourse:
       task=datamodel.getTask(i)
       break
if task==None:
   # create the task
   task=datamodel.addTask(CCopasiTask.timeCourse)
]]>
</programlisting>
</para>

<para>
The classes <emphasis>CCopasiProblem</emphasis> and <emphasis>CCopasiMethod</emphasis> are both derived from <emphasis>CCopasiParameterGroup</emphasis>, they inherit all the methods from <emphasis>CCopasiParameterGroup</emphasis> to set their parameters.
There are two ways to get a parameter, the first method retrieves a parameter by its index, the second method gets the parameter via its name.
</para>
<para condition="JAVA">
Older versions of the COPASI language bindings contained a bug and the getParameter(String name) would return a java object of type CCopasiParameter even if no parameter with that name existed in the parameter group.
In more recent versions, a null pointer is returned.
</para>
<para>The getIndex method can be used to find if a parameter with a certain name exists within the given parameter group. If the parameter does not exist in the parameter group the size_t value C_INVALID_INDEX is returned by the C++ API.
</para>
<para condition="Java">
The size_t value is architecture dependent which leads to problems when it is converted to the representation on the target language. E.g. on 32 bit virtual machines C_INVALID_INDEX is converted to the value 2^32, while on 64 bit java virtual machines it seems to be converted to the value -1.
To get around this problem, a static method called COPASI.INVALID_INDEX() has been created that returns the C++ value for C_INVALID_INDEX in an archiecture independent way.
So in order to find out, if a parameter exists, the value returned by the getINdex method can be compared to the value returned by COPASI.INVALID_INDEX() and this will work indepedent of the architecture that is used.
</para>
<para condition="Python">
The size_t value is architecture dependent which leads to problems when it is converted to the representation on the target language. E.g. on 32 bit virtual machines C_INVALID_INDEX is converted to the value 2^32, while on 64 bit java virtual machines it seems to be converted to the value -1. Although I haven'T tested this, I suspect that other target languages like python will have similar problems.
To get around this problem, a static method called COPASI.INVALID_INDEX() has been created that returns the C++ value for C_INVALID_INDEX in an architecture independent way.
So in order to find out, if a parameter exists, the value returned by the getINdex method can be compared to the value returned by COPASI.INVALID_INDEX() and this will work indepedent of the architecture that is used.
</para>


<para>
<programlisting condition="JAVA">
CCopasiParameter getParameter(long index);
CCopasiParameter getParameter(String name);
long getIndex(String name);
</programlisting>
<programlisting condition="CPP">
CCopasiParameter* getParameter(const unsigned C_INT32&amp; index);
const CCopasiParameter* getParameter(const unsigned C_INT32&amp; index) const;
CCopasiParameter* getParameter(const std::string&amp; name);
const CCopasiParameter* getParameter(const std::string&amp; name) const;
size_t getIndex(const std::string&amp; name) const;
</programlisting>
<programlisting condition="PYTHON">
PARAMETER=getParameter(INDEX)
PARAMETER=getParameter(PARAMETER_NAME_STRING)
INDEX=getIndex(PARAMETER_NAME_STRING)
</programlisting>
</para>

<para>
<emphasis>CCopasiParameterGroup</emphasis>s methods <emphasis>size()</emphasis> can be used to find out how many parameters are part of the parameter group.
Each instance of <emphasis>CCopasiParameter</emphasis> has a type that determines what kind of values are allowed for the parameter. E.g. it determines if the parameter represents an integer a float value or a string.
Depending on the type of the parameter which can be acquire with the <emphasis>type()</emphasis> method, the parameters value has to be set with a specific method.
Let us for example look at the parameter called "Duration" which is a parameter of CTrajectoryProblem and determines up to which time the simulation will be calculated. The parameter itself stores a double value. Assuming you already have the correct task, you can set this parameter as follows.    
</para>

<para>
<programlisting condition="JAVA">
<![CDATA[
CTrajectoryProblem problem=(CTrajectoryProblem)task.getProblem();
CCopasiParameter parameter=problem.getParameter("Duration");
if(parameter!=null && parameter.getType()==CCopasiParameter.UDOUBLE)
{
    parameter.setDblValue(100.3);
}]]>
</programlisting>
<programlisting condition="CPP">
<![CDATA[
CTrajectoryProblem* pProblem=(CTrajectoryProblem*)pTask->getProblem();
CCopasiParameter* pParameter=pProblem->getParameter("Duration");
if(pParameter!=NULL && pParameter->getType()==CCopasiParameter::UDOUBLE)
{
    pParameter->setValue(100.3);
}]]>
</programlisting>
<programlisting condition="PYTHON">
<![CDATA[
problem=task.getProblem()
parameter=problem.getParameter("Duration")
if parameter!=null && parameter.getType()==CCopasiParameter.UDOUBLE:
    parameter.setValue(100.3)
]]>
</programlisting>
</para>

<para>
This would set the parameter so that running a simulation would simulate a time length of $100.3$ time units. 
</para>

<para>
The types that are allowed for a parameter are defined in CCopasiParameter.java. The defined types as of the time of writing are those listed in table <link linkend="ParameterTypes">parameter types</link>.
</para>

<para>
<table xreflabel="ParameterTypes" id="ParameterTypes">
<title>parameter types</title>
<tgroup cols="2">
<thead>
<row>
<entry>Type</entry>
<entry>Description</entry>
</row>
</thead>
<tbody>
<row>
<entry>DOUBLE</entry>
<entry>a double value</entry>
</row>
<row>
<entry>UDOUBLE</entry>
<entry>a positive double value</entry>
</row>
<row>
<entry>INT</entry> 
<entry>an integer value (long)</entry>
</row>
<row>
<entry>UINT</entry> 
<entry>a positive integer value (long)</entry>
</row>
<row>
<entry>BOOL</entry> 
<entry>a boolean value (0 or 1)</entry>
</row>
<row>
<entry>GROUP</entry> 
<entry>a parameter group (parameter groups can be nested</entry>
</row>
<row>
<entry>STRING</entry>
<entry>a String</entry>
</row>
<row>
<entry>CN</entry> 
<entry>a COPASI common name (String)</entry>
</row>
<row>
<entry>KEY</entry>
<entry>a key (String)</entry>
</row>
<row>
<entry>FILE</entry>
<entry>a filename (String)</entry>
</row>
</tbody>
</tgroup>
</table>
</para>

<para>
Most of the time you will only have to deal with the numeric parameters of type DOUBLE, INT, UINT or BOOL.
</para>

<para>
Next the method has to be set on the task. The method of a task can be set with the <emphasis>setMethodType(int type)</emphasis> method of <emphasis>CCopasiTask</emphasis> the argument to the method is an integer that specifies the type of the method. All methods known to COPASI have a specific type and all those types are defined in CCopasiMethod.java. Not all methods are applicable to all tasks, normally a task has a certain set of methods that can be used with the task. If the method type passed to <emphasis>setMethodType</emphasis> is not applicable to the task on which the method has been called, the method return a value of <emphasis>false</emphasis>, otherwise it returns <emphasis>true</emphasis>.
To find out which method is currently set on a task, you can use a call to <emphasis>getMethodType()</emphasis> which will return an integer representing the method.
</para>

<para>
Which method can be used with which task will be described in the documentation for the individual tasks.
One the correct method has been set, the method parameters can be changed which works exactly the same way as described for the parameter of the problem above, the only difference is that the methods are used in an instance of <emphasis>CCopasiMethod</emphasis> which can be obtained from the task with a call to <emphasis>getMethod()</emphasis>.
</para>

<para>
Once everything has been set, the task can be executed by calling the <emphasis>process(boolean useInitialValues)</emphasis> method. The boolean argument to the method determines if the task will use the current values of all model elements to run or if all values will be reset the the elements initial values. Using the current values rather than the initial values might be useful if a simulation has already been run, but one wants to extend this simulation to get more data points.
When a task is run, the results are either stored in a report if one was defined, and/or in memory. How reports can be defined and how the results for a specific task can be obtained will be explained in the documentation for the specific tasks below.
</para>
</sect2>

<sect2 id="timeCource" xreflabel="timeCourse">
<title>Running Time Course Simulations</title>

<para>
The procedure for running a time course simulation has more or less already been described above. 
What remains to be explained is what parameters can be used on <emphasis>CTrajectoryProblem</emphasis> (table <link linkend="TrajectoryProblemParameters">trajectory problem parameters</link>}) and which methods can be used with <emphasis>CTrajectoryTask</emphasis> (table <link linkend="TrajectoryMethods">trajectory methods</link>).
</para>

<para>
<table id="TrajectoryProblemParameters" xreflabel="TrajectoryProblemParameters">
<title>trajectory problem parameters</title>
<tgroup cols="3">
<thead>
<row>
<entry>Name</entry>
<entry>Type</entry>
<entry>Description</entry>
</row>
</thead>
<tbody>
<row>
<entry>StepNumber</entry>
<entry>UINT</entry>
<entry>number of time steps that are calculated</entry>
</row>
<row>
<entry>StepSize</entry>
<entry>DOUBLE</entry>
<entry>size of each time step</entry>
</row>
<row>
<entry>Duration</entry>
<entry>DOUBLE</entry>
<entry>length of the simulation</entry>
</row>
<row>
<entry>TimeSeriesRequested</entry>
<entry>BOOL</entry>
<entry>determines if the result is to be stored in memory</entry>
</row>
<row>
<entry>OutputStartTime</entry>
<entry>DOUBLE</entry>
<entry>the time at which COPASI begins to produce output</entry>
</row>
</tbody>
</tgroup>
</table>
</para>

<para>
<table id="TrajectoryMethods" xreflabel="TrajectoryMethods">
<title>trajectory method types</title>
<tgroup cols="2">
<thead>
<row>
<entry>Type</entry>
<entry>Description</entry>
</row>
</thead>
<tbody>
<row>
<entry>deterministic</entry>
<entry>simulation with LSODA</entry>
</row>
<row>
<entry>LSODAR</entry>
<entry>simulation with LSODAR</entry>
</row>
<row>
<entry>stochastic</entry>
<entry>simulation with the next reaction method</entry>
</row>
<row>
<entry>hybrid</entry>
<entry>hybrid with next reaction method and runge kutta (4th order)</entry>
</row>
<row>
<entry>hybridLSODA</entry>
<entry>hybrid with next reaction method and LSODA</entry>
</row>
<row>
<entry>tauLeap </entry>
<entry>stochastic simulation with the tauLeap method</entry>
</row>
</tbody>
</tgroup>
</table>
</para>

<para>
Here a complete example on how it could be done:
</para>

<para>
<programlisting condition="JAVA">
<![CDATA[
long i=0;
long iMax=datamodel.getTaskList().size();
CTrajectoryTask task=null;
for(i=0;i<iMax;i++)
{
   if(datamodel.getTask(i).getType()==CCopasiTask.timeCourse)
   {
       task=datamodel.getTask(i);
       break;
   }
}
if(task==null)
{
   // create the task
   task=datamodel.addTask(CCopasiTask.timeCourse);
}
if(task!=null)
{
  CTrajectoryProblem problem=(CTrajectoryProblem)task.getProblem();
  CCopasiParameter parameter=problem.getParameter("Duration");
  if(parameter!=null && parameter.getType()==CCopasiParameter.UDOUBLE)
  {
    parameter.setDblValue(100.3);
  }
  if(task.setMethodType(CCopasiMethod.LSODAR))
  {
    // maybe change some method parameters
    task.process(true);
  }
  else
  {
    // error handling
  }
}]]>
</programlisting>
<programlisting condition="CPP">
<![CDATA[
long i=0;
long iMax=pDataModel->getTaskList()->size();
CTrajectoryTask* pTask=NULL;
for(i=0;i<iMax;i++)
{
   if((*pDataModel->getTasks())[i].getType()==CCopasiTask::timeCourse)
   {
       pTask=(*pDataModel->getTasks())[i];
       break;
   }
}
if(pTask==NULL)
{
   // create the task
   pTask=pDataModel->addTask(CCopasiTask::timeCourse);
}
if(pTask!=NULL)
{
  CTrajectoryProblem* pProblem=(CTrajectoryProblem*)pTask->getProblem();
  CCopasiParameter* pParameter=pProblem->getParameter("Duration");
  if(pParameter!=NULL && pParameter->getType()==CCopasiParameter::UDOUBLE)
  {
    pParameter->setValue(100.3);
  }
  if(pTask->setMethodType(CCopasiMethod::LSODAR))
  {
    // maybe change some method parameters
    pTask->initialize(CCopasiTask::OUTPUT_COMPLETE, pDataModel, NULL);
    pTask->process(true);
    pTask->restore();

  }
  else
  {
    // error handling
  }
}]]></programlisting>
<programlisting condition="PYTHON">
<![CDATA[
iMax=datamodel.getTaskList().size()
task=None
for i in range(0,iMax):
   if datamodel.getTask(i).getType()==CCopasiTask.timeCourse:
       task=datamodel.getTask(i)
       break
if task==None:
   # create the task
   task=datamodel.addTask(CCopasiTask.timeCourse)
if task!=None:
  problem=task.getProblem()
  parameter=problem.getParameter("Duration")
  if(parameter!=null && parameter.getType()==CCopasiParameter.UDOUBLE)
    parameter.setValue(100.3)
  if task.setMethodType(CCopasiMethod.LSODAR):
    # maybe change some method parameters
    task.process(true)
  else
    # error handling
    ...
]]>
</programlisting>
</para>

<para>
After running the time course simulation the results are stored in memory if the "TimeSeriesRequested" parameter was set to <emphasis>true</emphasis>. In order to get the results from the simulation <emphasis>CTrajectoryTask</emphasis> provides the method <emphasis>getTimeSeries()</emphasis> which returns an instance of <emphasis>CTimeSeries</emphasis>.
<emphasis>CTimeSeries</emphasis> itself provides some methods to read out the results.
</para>

<para>
<programlisting condition="JAVA">
/**
 * Returns the number of steps in the time series.
 * This should be the same number as the "StepNumber"
 * parameter of the CTrajectoryProblem instance plus
 * one for the initial state.
 */
long getRecordedSteps();

/**
 * Returns the number of variables in each row of
 * the result. Which is the same as the number of 
 * columns. This includes the column for time.
 */
long getNumVariables();

/**
 * Gets the value for a specific row and column of 
 * the result. The rows are the individual time steps 
 * and the columns are the variables.
 * Indices begin with 0 and the first column (var=0) is 
 * the time.
 * If the column represents a metabolite, this method 
 * returns the particle number.
 */
double getData(long step, long var);

/**
 * Gets the value for a specific row and column of
 * the result. The rows are the individual time steps
 * and the columns are the variables.
 * Indices begin with 0 and the first column (var=0)
 * is the time.
 * If the column represents a metabolite, this method
 * returns the concentration.
 * For all other columns, the value is the same as the 
 * one you get with getData.
 */
double getConcentrationData(long step, long var);

/**
 * Get the key (id) of the element represented by the
 * column with index var.
 */
String getKey(long var);

/**
 * Get the SBML id of the element represented by the column
 * with index var.
 * Objects only have SBML ids if the model was imported from 
 * an SBML file, or has already been exported to an SBML file.
 */
String getSBMLId(long var);
</programlisting>
<programlisting condition="CPP">
/**
 * Returns the number of steps in the time series.
 * This should be the same number as the "StepNumber"
 * parameter of the CTrajectoryProblem instance plus
 * one for the initial state.
 */
const unsigned C_INT32&amp; getRecordedSteps() const;

/**
 * Returns the number of variables in each row of
 * the result. Which is the same as the number of 
 * columns. This includes the column for time.
 */
const unsigned C_INT32&amp; getNumVariables() const;

/**
 * Gets the value for a specific row and column of 
 * the result. The rows are the individual time steps 
 * and the columns are the variables.
 * Indices begin with 0 and the first column (var=0) is 
 * the time.
 * If the column represents a metabolite, this method 
 * returns the particle number.
 */
const C_FLOAT64&amp; getData(const unsigned C_INt32&amp; step, const unsigned C_INT32&amp; var) const;

/**
 * Gets the value for a specific row and column of
 * the result. The rows are the individual time steps
 * and the columns are the variables.
 * Indices begin with 0 and the first column (var=0)
 * is the time.
 * If the column represents a metabolite, this method
 * returns the concentration.
 * For all other columns, the value is the same as the 
 * one you get with getData.
 */
const C_FLOAT64&amp; getConcentrationData(const unsigned C_INT32&amp; step, const unsigned C_INT32&amp; var) const;

/**
 * Get the key (id) of the element represented by the
 * column with index var.
 */
const std::string&amp; getKey(const unsigned C_INT32&amp; var) const;

/**
 * Get the SBML id of the element represented by the column
 * with index var.
 * Objects only have SBML ids if the model was imported from 
 * an SBML file, or has already been exported to an SBML file.
 */
const std::string&amp; getSBMLId(const unsigned C_INT32&amp; var);
</programlisting>
<programlisting condition="PYTHON">
# 
# Returns the number of steps in the time series.
# This should be the same number as the "StepNumber"
# parameter of the CTrajectoryProblem instance plus
# one for the initial state.
# 
NUM_STEPS=getRecordedSteps()

# 
# Returns the number of variables in each row of
# the result. Which is the same as the number of 
# columns. This includes the column for time.
# 
NUM_VARIABLES=getNumVariables()

# 
# Gets the value for a specific row and column of 
# the result. The rows are the individual time steps 
# and the columns are the variables.
# Indices begin with 0 and the first column (var=0) is 
# the time.
# If the column represents a metabolite, this method 
# returns the particle number.
# 
VALUE=getData(STEP_NUMBER, VARIABLE_INDEX)

# 
# Gets the value for a specific row and column of
# the result. The rows are the individual time steps
# and the columns are the variables.
# Indices begin with 0 and the first column (var=0)
# is the time.
# If the column represents a metabolite, this method
# returns the concentration.
# For all other columns, the value is the same as the 
# one you get with getData.
# 
VALUE=getConcentrationData(STEP_NUMBER, VARIABLE_INDEX)

# 
# Get the key (id) of the element represented by the
# column with index var.
# 
KEY_STRING=getKey(VARIABLE_INDEX)

# 
# Get the SBML id of the element represented by the column
# with index var.
# Objects only have SBML ids if the model was imported from 
# an SBML file, or has already been exported to an SBML file.
# 
ID_STRING=getSBMLId(VARIABLE_INDEX)
</programlisting>
</para>
<para condition="PYTHON">
For the python bindings there exists a number of additional convenience methods
to read the time course data from an instance of CTimeCourse.

<programlisting>
# Returns the titles of the variables in the time series
# as a python list.
# If the time series contains no variables, an empty list is returned.
title_list=getTitles()

# Returns the complete time course particle number data for the variable with the given index.
# The index has to be an integer type, otherwise an AttributeError is raised.
# If the given index is invalid, None is returned.
particle_number_list=getDataForIndex(index)

# Returns the complete time course concentration data for the variable with the given index.
# The index has to be an integer type, otherwise an AttributeError is raised.
# If the given index is invalid, None is returned.
concentration_list=getConcentrationDataForIndex(index)

# Returns the complete time course particle number data for the variable corresponding to the given object.
# The key of the object must match the key of one of the variables of the time course as returned by the getKey method.
# If no fitting key is found, None is returned.
# The object argument must be an instance of CCopasiObject, otherwise an AttributeError is raised. 
particle_number_list=getDataForObject(object)


# Returns the complete time course concentration data for the variable corresponding to the given object.
# The key of the object must match the key of one of the variables of the time course as returned by the getKey method.
# If no fitting key is found, None is returned.
# The object argument must be an instance of CCopasiObject, otherwise an AttributeError is raised. 
concentration_list=getConcentrationDataForObject(object)

</programlisting>
</para>


</sect2>

<sect2 id="steadyState" xreflabel="steadyState">
<title>Performing Steady State Calculations</title>

<para>
Performing a steady state calculation is very similar to running a time course simulation. There is a task instance (<emphasis>CSteadyStateTask</emphasis>) that contains a problem instance (<emphasis>CSteadyStateProblem</emphasis>) and a method instance (<emphasis>CNewtonMethod</emphasis>).
At the time this was written, there is only one method for the steady state calculation, so we have to deal with a fixed set of parameters that can be set on the problem and the method.
The steady state problem has two parameters. One (<emphasis>JacobianRequested</emphasis>) determines if the Jacobian matrix is to be calculated and the other (<emphasis>StabilityAnalysisRequested</emphasis>) determines if a stability analysis is to be done. Both values are boolean values and per default they are set to <emphasis>true</emphasis>.
</para>

<para>
The <emphasis>CNewtonMethod</emphasis> has the following parameters:
</para>

<para>
<variablelist>
<varlistentry>
<term>Resolution</term>
<listitem><para>Resolution to determine if a steady state has been found (Double)</para></listitem>
</varlistentry>
<varlistentry>
<term>Derivation Factor</term>
<listitem><para>Used to determine the step size used for numerical differentiation (Double)</para></listitem>
</varlistentry>
<varlistentry>
<term>Use Newton</term>
<listitem><para>Use the Newton method to find steady states (Boolean) </para></listitem>
</varlistentry>
<varlistentry>
<term>Use Integration</term>
<listitem><para>Use integration to find steady states (Boolean)</para></listitem>
</varlistentry>
<varlistentry>
<term>Use Back Integration</term>
<listitem><para>Use backwards integration to find steady states (Boolean)</para></listitem>
</varlistentry>
<varlistentry>
<term>Accept Negative Concentrations</term>
<listitem><para>Accept a steady state with negative concentrations (Boolean)</para></listitem>
</varlistentry>
<varlistentry>
<term>Iteration Limit</term>
<listitem><para>Maximum number of iterations for the newton method (positive Integer)</para></listitem>
</varlistentry>
</variablelist>
</para>

<para>
For a detailed description of all these parameters please have a look in the COPASI manual in the section for the steady state method.
To run the calculation, the <emphasis>process</emphasis> method of the task has to be used. The method takes two arguments. The first argument is a <emphasis>boolean</emphasis> value that determines whether the task is started with the current model values or with the initial values of all model entities. The second argument is an int value that can be either <emphasis>CCopasiTask.NO_OUTPUT</emphasis> or <emphasis>CCopasiTask.OUTPUT_COMPLETE</emphasis> which determined if output is generated from the task or not. This is important if reports have been defined for the task (see section <link linkend="reports">Creating Reports</link>). 
</para>

<para>
After the task has finished, the results can be queried via several methods provided by the <emphasis>CSteadyStateTask</emphasis> instance.
</para>

<para>
<programlisting condition="JAVA">
/**
 * Returns an integer value. The value can either be
 * CSteadyStateMethod.notFound, CSteadyStateMethod.found,
 * CSteadyStateMethod.foundEquilibirium or
 * CSteadyStateMethod.foundNegative depending on whether 
 * a steady state was found and what properties the 
 * found steady state has.
 */
public int getResult();

/**
 * If a steady state was found, the corresponding state
 * of the model can be acquire by this method.
 */
public CState getState();

/**
 * Returns the Jacobian Matrix that was calculated.
 * The returned FloatMatrix object has the method size
 * to query its size and the methods numCols() and 
 * numRows() to query for the number of columns and the
 * number of rows respectively.
 * Individual elements from the matrix can be fetched
 * with the get method which takes the row and the column
 * index as its two arguments.
 * Indices are specified as long values, the return values
 * are of type double.
 */
public FloatMatrix getJacobian();

/**
 * Returns the Jacobian Matrix together with annotations
 * as to which column and row corresponds to what.
 */
public CArrayAnnotation getJacobianAnnotated();

/**
 * Returns the Jacobian matrix for the reduced model 
 * (removed mass conservations).
 * The returned FloatMatrix object has the method size
 * to query its size and the methods numCols() and numRows()
 * to query for the number of columns and the number of rows
 * respectively.
 * Individual elements from the matrix can be fetched with 
 * the get method which takes the row and the column index
 * as its two arguments.
 * Indices are specified as long values, the return values
 * are of type double.
 */
public FloatMatrix getJacobianReduced();

/**
 * Returns the annotated Jacobian matrix for the reduced model 
 * (removed mass conservations).
 */
public CArrayAnnotation getJacobianXAnnotated();

/**
 * Returns the Eigenvalues for the full model.
 */
public CEigen getEigenValues();

/**
 * Returns the Eigenvalues for the reduced model.
 */
public CEigen getEigenValuesReduced();
</programlisting>
<programlisting condition="CPP">
/**
 * Returns an integer value. The value can either be
 * CSteadyStateMethod::notFound, CSteadyStateMethod::found,
 * CSteadyStateMethod::foundEquilibirium or
 * CSteadyStateMethod::foundNegative depending on whether 
 * a steady state was found and what properties the 
 * found steady state has.
 */
const CSteadyStateMethod::ReturnCode&amp; getResult() const;

/**
 * If a steady state was found, the corresponding state
 * of the model can be acquire by this method.
 */
const CState* getState() const;

/**
 * Returns the Jacobian Matrix that was calculated.
 * The returned matrix object has the method size
 * to query its size and the methods numCols() and 
 * numRows() to query for the number of columns and the
 * number of rows respectively.
 * Individual elements from the matrix can be fetched
 * with the get method which takes the row and the column
 * index as its two arguments.
 * Indices are specified as long values, the return values
 * are of type double.
 */
 const CMatrix&lt;C_FLOAT64&gt;&amp; getJacobian() const;

/**
 * Returns the Jacobian Matrix together with annotations
 * as to which column and row corresponds to what.
 */
const CArrayAnnotation* getJacobianAnnotated() const;

/**
 * Returns the Jacobian matrix for the reduced model 
 * (removed mass conservations).
 * The returned matrix object has the method size
 * to query its size and the methods numCols() and numRows()
 * to query for the number of columns and the number of rows
 * respectively.
 * Individual elements from the matrix can be fetched with 
 * the get method which takes the row and the column index
 * as its two arguments.
 * Indices are specified as long values, the return values
 * are of type double.
 */
 const CMatrix&lt;C_FLOAT64&gt;&amp; getJacobianReduced() const;

/**
 * Returns the annotated Jacobian matrix for the reduced model 
 * (removed mass conservations).
 */
 const CArrayAnnotation* getJacobianXAnnotated() const;

/**
 * Returns the Eigenvalues for the full model.
 */
const CEigen&amp; getEigenValues() const;

/**
 * Returns the Eigenvalues for the reduced model.
 */
const CEigen&amp; getEigenValuesReduced() const;
</programlisting>
<programlisting condition="PYTHON">
# 
# Returns an integer value. The value can either be
# CSteadyStateMethod.notFound, CSteadyStateMethod.found,
# CSteadyStateMethod.foundEquilibirium or
# CSteadyStateMethod.foundNegative depending on whether 
# a steady state was found and what properties the 
# found steady state has.
# 
RESULT=getResult()

# 
# If a steady state was found, the corresponding state
# of the model can be acquire by this method.
# 
STATE=getState()

# 
# Returns the Jacobian Matrix that was calculated.
# The returned FloatMatrix object has the method size
# to query its size and the methods numCols() and 
# numRows() to query for the number of columns and the
# number of rows respectively.
# Individual elements from the matrix can be fetched
# with the get method which takes the row and the column
# index as its two arguments.
# Indices are specified as long values, the return values
# are of type double.
# 
JACOBIAN=getJacobian()

# 
# Returns the Jacobian Matrix together with annotations
# as to which column and row corresponds to what.
# 
ANNOTATED_JACOBIAN=getJacobianAnnotated()

# 
# Returns the Jacobian matrix for the reduced model 
# (removed mass conservations).
# The returned FloatMatrix object has the method size
# to query its size and the methods numCols() and numRows()
# to query for the number of columns and the number of rows
# respectively.
# Individual elements from the matrix can be fetched with 
# the get method which takes the row and the column index
# as its two arguments.
# Indices are specified as long values, the return values
# are of type double.
# 
REDUCED_JACOBIAN=getJacobianReduced()

# 
# Returns the annotated Jacobian matrix for the reduced model 
# (removed mass conservations).
# 
ANNOTATED_JACOBIAN=getJacobianXAnnotated()

# 
# Returns the Eigenvalues for the full model.
# 
EIGENVALUES=getEigenValues()

# 
# Returns the Eigenvalues for the reduced model.
# 
EIGENVALUES=getEigenValuesReduced()
</programlisting>
</para>

<para>
<variablelist>
<varlistentry condition="JAVA">
<term>CSteadyStateMethod.notFound</term>
<listitem><para>no steady state was found</para></listitem>
</varlistentry>
<varlistentry>
<term>CSteadyStateMethod.found</term>
<listitem><para>a steady state was found</para></listitem>
</varlistentry>
<varlistentry>
<term>CSteadyStateMethod.foundEquilibrium</term>
<listitem><para>a steady state was found where all reaction fluxes are zero</para></listitem>
</varlistentry>
<varlistentry>
<term>CSteadyStateMethod.foundNegative</term>
<listitem><para>a steady state with negative concentrations was found</para></listitem>
</varlistentry>
</variablelist>
<variablelist condition="CPP">
<varlistentry>
<term>CSteadyStateMethod::notFound</term>
<listitem><para>no steady state was found</para></listitem>
</varlistentry>
<varlistentry>
<term>CSteadyStateMethod::found</term>
<listitem><para>a steady state was found</para></listitem>
</varlistentry>
<varlistentry>
<term>CSteadyStateMethod::foundEquilibrium</term>
<listitem><para>a steady state was found where all reaction fluxes are zero</para></listitem>
</varlistentry>
<varlistentry>
<term>CSteadyStateMethod::foundNegative</term>
<listitem><para>a steady state with negative concentrations was found</para></listitem>
</varlistentry>
</variablelist>
<variablelist condition="PYTHON">
<varlistentry>
<term>CSteadyStateMethod.notFound</term>
<listitem><para>no steady state was found</para></listitem>
</varlistentry>
<varlistentry>
<term>CSteadyStateMethod.found</term>
<listitem><para>a steady state was found</para></listitem>
</varlistentry>
<varlistentry>
<term>CSteadyStateMethod.foundEquilibrium</term>
<listitem><para>a steady state was found where all reaction fluxes are zero</para></listitem>
</varlistentry>
<varlistentry>
<term>CSteadyStateMethod.foundNegative</term>
<listitem><para>a steady state with negative concentrations was found</para></listitem>
</varlistentry>
</variablelist>
</para>

<para>
The class <emphasis>CEigen</emphasis> class provides several methods to determine the characteristics of the Eigenvalues.
</para>

<para>
<programlisting condition="JAVA">
/**
 * Returns the largest real part in all Eigenvalues.
 */
public double getMaxrealpart();

/**
 * Returns the largest imaginary part in all Eigenvalues.
 */
public double getMaximagpart();

/**
 * Returns the number of non-zero Eigenvalues.
 */
public int getNzero();

/**
 * Returns the stiffness of the Eigenvalues.
 */
public double getStiffness();

/**
 * Returns the hierarchy of the Eigenvalues.
 */
public double getHierarchy();

/**
 * Returns the number of Eigenvalues with an
 * imaginary part equal to zero.
 */
public int getNreal();

/**
 * Returns the number of Eigenvalues with an
 * imaginary part different from zero.
 */
public int getNimag();

/**
 * Get the number of Eigenvalues with
 * a positive real part.
 */
public int getNposreal();

/**
 * Get the number of Eigenvalues with
 * a negative real part.
 */
public int getNnegreal();

/**
 * Returns a vector with the imaginary parts of
 * all Eigenvalues.
 * The vectors size can be queried with the size method.
 * Individual elements can be acquire with the get method.
 */
public FloatCVector getI();

/**
 * Returns a vector with the real parts of
 * all Eigenvalues.
 * The vectors size can be queried with the size method.
 * Individual elements can be acquire with the get method.
 */
public FloatCVector getR();
</programlisting>
<programlisting condition="CPP">
/**
 * Returns the largest real part in all Eigenvalues.
 */
const C_FLOAT&amp; getMaxrealpart() const;

/**
 * Returns the largest imaginary part in all Eigenvalues.
 */
const C_FLOAT64 &amp; getMaximagpart() const;

/**
 * Returns the number of non-zero Eigenvalues.
 */
const C_INT32 &amp; getNzero() const;

/**
 * Returns the stiffness of the Eigenvalues.
 */
const C_FLOAT64 &amp; getStiffness() const;

/**
 * Returns the hierarchy of the Eigenvalues.
 */
const C_FLOAT64 &amp; getHierarchy() const;

/**
 * Returns the number of Eigenvalues with an
 * imaginary part equal to zero.
 */
const C_INT32 &amp; getNreal() const;

/**
 * Returns the number of Eigenvalues with an
 * imaginary part different from zero.
 */
const C_INT32 &amp; getNimag() const;

/**
 * Get the number of Eigenvalues with
 * a positive real part.
 */
const C_INT32 &amp; getNposreal() const;

/**
 * Get the number of Eigenvalues with
 * a negative real part.
 */
const C_INT32 &amp; getNnegreal() const;

/**
 * Returns a vector with the imaginary parts of
 * all Eigenvalues.
 * The vectors size can be queried with the size method.
 * Individual elements can be acquire with the get method.
 */
const CVector&lt;C_FLOAT64&gt;&amp; getI() const;

/**
 * Returns a vector with the real parts of
 * all Eigenvalues.
 * The vectors size can be queried with the size method.
 * Individual elements can be acquire with the get method.
 */
const CVector&lt;C_FLOAT64&gt;&amp; getR() const;
</programlisting>
<programlisting condition="PYTHON">
# 
# Returns the largest real part in all Eigenvalues.
# 
MAX_REAL_PART=getMaxrealpart()

# 
# Returns the largest imaginary part in all Eigenvalues.
# 
MAX_IMAG_PART=getMaximagpart()

# 
# Returns the number of non-zero Eigenvalues.
# 
NUM_NONZERO=getNzero()

# 
# Returns the stiffness of the Eigenvalues.
# 
STIFFNESS=getStiffness()

# 
# Returns the hierarchy of the Eigenvalues.
# 
HIERARCHY=getHierarchy()

# 
# Returns the number of Eigenvalues with an
# imaginary part equal to zero.
# 
NUM_REAL=getNreal()

# 
# Returns the number of Eigenvalues with an
# imaginary part different from zero.
# 
NUM_IMAG=getNimag()

# 
# Get the number of Eigenvalues with
# a positive real part.
# 
NUM_POS_REAL=getNposreal()

# 
# Get the number of Eigenvalues with
# a negative real part.
# 
NUM_NEG_REAL=getNnegreal()

# 
# Returns a vector with the imaginary parts of
# all Eigenvalues.
# The vectors size can be queried with the size method.
# Individual elements can be acquire with the get method.
# 
IMAG_PART_VECTOR=getI()

# 
# Returns a vector with the real parts of
# all Eigenvalues.
# The vectors size can be queried with the size method.
# Individual elements can be acquire with the get method.
# 
REAL_PART_VECTOR=getR()
</programlisting>
</para>

<para>
The <emphasis>CArrayAnnotation</emphasis> class provides a matrix of values combined with annotation data that provides information on the rows and columns of the matrix.
The values of the contained matrix can be acquire the same way as for the float matrix with the <emphasis>get</emphasis> method. The method takes two arguments which are the row and the column index.
The further methods provided are the following:
</para>

<para>
<programlisting condition="JAVA">
/**
 * Returns the number of dimensions of the contained matrix.
 */
public long dimensionality();

/**
 * Returns a vector of common names for the given 
 * dimension of the matrix.
 */
public ReportItemVector getAnnotationsCN(long d);

/**
 * Returns a vector of strings that represent the 
 * column entries in dimension d. The display
 * argument determines whether the string contain
 * the display name or the object name of the object 
 * represented in a column.
 * A value of true means that display names are returned.
 */
public StringStdVector getAnnotationsString(long d, boolean display);

/**
 * Same as the method above, only that the second
 * argument is assumed to be true. So the returned
 * vector will contain display names.
 */
public StringStdVector getAnnotationsString(long d);

/**
 * Gets a description of what is represented by the 
 * dimension given as the argument to the method.
 */  
public String getDimensionDescription(long d);

/**
 * Returns a description of the matrix.
 */
public String getDescription();
</programlisting>
<programlisting condition="CPP">
/**
 * Returns the number of dimensions of the contained matrix.
 */
unsigned int  dimensionality() const;

/**
 * Returns a vector of common names for the given 
 * dimension of the matrix.
 */
const std::vector&lt;CRegisteredObjectName&gt;&amp; getAnnotationsCN(unsigned int d) const;

/**
 * Returns a vector of strings that represent the 
 * column entries in dimension d. The display
 * argument determines whether the string contain
 * the display name or the object name of the object 
 * represented in a column.
 * A value of true means that display names are returned.
 */
const std::vector&lt;std::string&gt;&amp; getAnnotationsString(unsigned int d, bool display = true) const;

/**
 * Gets a description of what is represented by the 
 * dimension given as the argument to the method.
 */  
const std::string &amp; getDimensionDescription(unsigned int d) const;

/**
 * Returns a description of the matrix.
 */
const std::string &amp; getDescription() const;
</programlisting>
<programlisting condition="PYTHON">
# 
# Returns the number of dimensions of the contained matrix.
# 
DIMENSIONALITY=dimensionality()

# 
# Returns a vector of common names for the given 
# dimension of the matrix.
# 
REPORT_ITEM_VECTOR=getAnnotationsCN(DIMENSION)

# 
# Returns a vector of strings that represent the 
# column entries in dimension d. The display
# argument determines whether the string contain
# the display name or the object name of the object 
# represented in a column.
# A value of true means that display names are returned.
# 
STRING_VECTOR=getAnnotationsString(DIMENSION, RETURN_DISPLAY_STRING)

# 
# Same as the method above, only that the second
# argument is assumed to be true. So the returned
# vector will contain display names.
# 
STRING_VECTOR=getAnnotationsString(DIMENSION)

# 
# Gets a description of what is represented by the 
# dimension given as the argument to the method.
#   
DESCRIPTION_STRING=getDimensionDescription(DIMENSION)

# 
# Returns a description of the matrix.
# 
DESCRIPTION=getDescription()
</programlisting>
</para>

<para>
The result of the steady state calculation is read directly from the state of the model itself, because after the calculation of the steadystate, the model will contain that state in the transient values of all model entities. So if one wants to find the concentration of some metabolite at the steady state, it can be acquire directly by getting the transient concentration from this metabolite.
This works as long as the model has not been changed by adding or removing model entities or by doing any calculations on the model.
</para>
</sect2>


<sect2 id="parameterScans" xreflabel="parameterScans">
<title>Running Parameter Scans</title>

<para>
The scan task differs somewhat from the other tasks described so far. For example it is not necessary to set method and problem parameters the way it was done for the time course task.p
There are few parameters that have to be set and those can be set by convenience functions.
The classes that are needed to run a parameter scan are <emphasis>CScanTask</emphasis>, <emphasis>CScanMethod</emphasis> and <emphasis>CScanProblem</emphasis>.
There are three parameters that can be set on the <emphasis>CScanProblem</emphasis> instance through methods of that class.
</para>

<para>
<programlisting condition="JAVA">
/**
 * This method set the subtask for which the scan task
 * can be run. E.g. whether the scan is run on a steady
 * state calculation or on a time course.
 * Allowed types are defined in CCopasiTask.java.
 */
public void setSubtask(int type);

/**
 * Returns the type of the subtask for which the parameter
 * scan is run.
 */
public int getSubtask();

/**
 * This method sets whether the initial values of the model
 * are set to the result of each run of the subtask or if the 
 * initial values should be set to the original initial values
 * of the model.
 * A value of false means always use the original initial
 * values and a value of true means use the result of the last 
 * run as initial state for the next run.
 */
public void setAdjustInitialConditions(boolean aic);

/**
 * Returns true or false depending on whether the scan will adjust
 * the initial values of the model after each run of the subtask.
 */
public boolean getAdjustInitialConditions();

/**
 * This methods sets whether output from the subtask is
 * collected, or if the output only consists of the end-
 * result of each subtask.
 * Assuming the subtask is a time course simulation, 
 * setting this to true will produce a time course for
 * each run of the subtask. If the value is set to false,
 * only the end state of each time course simulation will
 * be written to the report.
 */
public void setOutputInSubtask(boolean ois);

/**
 * Returns true or false depending on whether output from the
 * subtask is collected or not.
 */
public boolean getOutputInSubtask();
</programlisting>
<programlisting condition="CPP">
/**
 * This method set the subtask for which the scan task
 * can be run. E.g. whether the scan is run on a steady
 * state calculation or on a time course.
 * Allowed types are defined in CCopasiTask.h
 */
void setSubtask(CCopasiTaskType::Type type);

/**
 * Returns the type of the subtask for which the parameter
 * scan is run.
 */
CCopasiTask::Type getSubtask() const;

/**
 * This method sets whether the initial values of the model
 * are set to the result of each run of the subtask or if the 
 * initial values should be set to the original initial values
 * of the model.
 * A value of false means always use the original initial
 * values and a value of true means use the result of the last 
 * run as initial state for the next run.
 */
 void setAdjustInitialConditions(bool aic);

/**
 * Returns true or false depending on whether the scan will adjust
 * the initial values of the model after each run of the subtask.
 */
const bool&amp; getAdjustInitialConditions() const;

/**
 * This methods sets whether output from the subtask is
 * collected, or if the output only consists of the end-
 * result of each subtask.
 * Assuming the subtask is a time course simulation, 
 * setting this to true will produce a time course for
 * each run of the subtask. If the value is set to false,
 * only the end state of each time course simulation will
 * be written to the report.
 */
void setOutputInSubtask(bool ois);

/**
 * Returns true or false depending on whether output from the
 * subtask is collected or not.
 */
const bool&amp; getOutputInSubtask() const;
</programlisting>
<programlisting condition="PYTHON">
# 
# This method set the subtask for which the scan task
# can be run. E.g. whether the scan is run on a steady
# state calculation or on a time course.
# Allowed types are defined in CCopasiTask.
# 
setSubtask(SUBTASK_TYPE)

# 
# Returns the type of the subtask for which the parameter
# scan is run.
# 
SUBTASK_TYPE=getSubtask()

# 
# This method sets whether the initial values of the model
# are set to the result of each run of the subtask or if the 
# initial values should be set to the original initial values
# of the model.
# A value of false means always use the original initial
# values and a value of true means use the result of the last 
# run as initial state for the next run.
#
setAdjustInitialConditions(DO_ADJUST_INITIAL_CONDITIONS)

# 
# Returns true or false depending on whether the scan will adjust
# the initial values of the model after each run of the subtask.
# 
ADJUST_INITIAL_CONDITIONS=getAdjustInitialConditions()

# 
# This methods sets whether output from the subtask is
# collected, or if the output only consists of the end-
# result of each subtask.
# Assuming the subtask is a time course simulation, 
# setting this to true will produce a time course for
# each run of the subtask. If the value is set to false,
# only the end state of each time course simulation will
# be written to the report.
# 
setOutputInSubtask(DO_OUTPUT_IN_SUBTASK)

# 
# Returns true or false depending on whether output from the
# subtask is collected or not.
# 
OUTPUT_FROM_SUBTASK=getOutputInSubtask()
</programlisting>
</para>

<para>
In order to run a parameter scan, one or more so called scan items have to be defined. Currently COPASI knows three types of scan items: repeat, linear and random. A parameter scan can define several scan items that are stacked and each scan item is applied to the scan item directly beneath it. The simplest scan item is the repeat type. It repeats the scan item (or if it is the lowest scan item it repeats the subtask) below it a certain number of times. No parameter is changed by this scan item type. This can e.g. be used to run a stochastic simulation several times with different random number seeds. (The stochastic time course simulation has a parameter that determines if it is started with a random seed, if this is set to false, the exactly same stochastic simulation will be run several times.)
The linear scan item changes an associated model value (usually this will be the initial value of some model entity) within a given range. The stepsize is determined by the number of steps that is given as a parameter. The name of this scan item might be somewhat misleading since it can also change the associated value in a logarithmic fashion rather than in a linear fashion.
Last but not least the random scan item can be used to initialize the associated value with a random value. The random value is determined by a permitted range and a distribution function.
The scan items are implemented as a nested parameter group. All parameters for the scan items are actually parameters that are stored in a parameter group which represents a scan item.
The class <emphasis>CScanProblem</emphasis> which itself is also derived from <emphasis>CCopasiParameterGroup</emphasis> contains a parameter group called <emphasis>ScanItems</emphasis> which holds all the scan items.
So in the end the instance of <emphasis>CScanProblem</emphasis> holds a parameter group called <emphasis>ScanItems</emphasis> which holds parameter groups that represent the individual scan items and those groups hold the parameters that determine the properties of the scan items.
</para>

<para>
The following list shows the properties of the individual scan item types:
</para>

<para>
<table>
<title>scan item parameters</title>
<tgroup cols="3">
<thead>
<row>
<entry>Parameter name</entry>
<entry>description</entry>
<entry>availability</entry>
</row>
</thead>
<tbody>
<row>
<entry>Number of steps (integer)</entry>
<entry>The number of steps of the scan item. For a repeat or a random scan item this is the number of repetitions, for the linear scan item this is used to determine the stepsize</entry>
<entry>all scan items</entry>
</row>
<row>
<entry>Type (integer)</entry>
<entry>The type of the scan item (CScanProblem.SCAN_RANDOM, CScanProblem.SCAN_REPEAT or CScanProblem.SCAN_LINEAR)</entry>
<entry>all scan items</entry>
</row>
<row>
<entry>Object (String)</entry>
<entry>The common name of the object associated with the scan item. For the repeat scan item this is usually an empty string</entry>
<entry>all scan items</entry>
</row>
<row>
<entry>log (boolean)</entry>
<entry>determines if the value is changed in a logarithmic fashion</entry>
<entry>linear scan item</entry>
</row>
<row>
<entry>Minimum (double)</entry>
<entry>lower bound</entry>
<entry>linear and random scan item</entry>
</row>
<row>
<entry>Maximum (double)</entry>
<entry>upper bound</entry>
<entry>linear and random scan item</entry>
</row>
<row>
<entry>Distribution type (integer)</entry>
<entry>determines which distribution the random numbers follow (CScanProblem.SD_UNIFORM, CScanProblem.SD_GAUSS and CScanProblem.SD_BOLTZ)</entry>
<entry>random scan item</entry>
</row>
</tbody>
</tgroup>
</table>
</para>

<para>
The following example codes shows how to run a simple parameter scan. It sets up the parameter scan to contain one repeat scan item that repeats the specified subtask 10 times:
</para>

<para>
<programlisting condition="JAVA">
CScanTask scanTask=
      (CScanTask)datamodel.addTask(CCopasiTask.scan);
CScanProblem scanProblem=(CScanProblem)scanTask.getProblem();
// set the desired subtask
scanProblem.setSubtask(CCopasiTask.timeCourse);
// always use the same initial values
scanProblem.setAdjustInitialConditions(false);
// get the ScanItems parameter group from the problem
CCopasiParameterGroup scanItems=scanProblem.getGroup("ScanItems");
// create a new parameter group to hold a scan item
CCopasiParameterGroup scanItem=new CCopasiParameterGroup("scanItem");
// add the parameters "Number of steps", "Type" and "Object" to the 
// scan item and set their values
parameterGroup.addParameter("Number of steps",
                        CCopasiParameter.UINT);
CCopasiParameter parameter=parameterGroup.getParameter("Number of steps");
parameter.setUIntValue(10);
parameterGroup.addParameter("Type", CCopasiParameter.UINT);
parameter=parameterGroup.getParameter("Type")
parameter.setUIntValue(CScanProblem.SCAN_REPEAT);
parameterGroup.addParameter("Object", CCopasiParameter.CN);
parameter=parameterGroup.getParameter("Object");
parameter.setStringValue("");
try
{
  result=scanTask.process(true);
}
catch(Exception e)
{
    System.err.println("ERROR: "+e.getMessage());
}
</programlisting>
<programlisting condition="CPP">
CScanTask* pScanTask=(CScanTask*)pDataModel->addTask(CCopasiTask::scan);
CScanProblem pScanProblem=(CScanProblem*)pScanTask->getProblem();
// set the desired subtask
pScanProblem->setSubtask(CCopasiTask::timeCourse);
// always use the same initial values
pScanProblem->setAdjustInitialConditions(false);
// get the ScanItems parameter group from the problem
CCopasiParameterGroup* pScanItems=pScanProblem->getGroup("ScanItems");
// create a new parameter group to hold a scan item
CCopasiParameterGroup* pScanItem=new CCopasiParameterGroup("scanItem");
// add the parameters "Number of steps", "Type" and "Object" to the 
// scan item and set their values
pParameterGroup->addParameter("Number of steps",
                        CCopasiParameter::UINT);
CCopasiParameter* pParameter=pParameterGroup->getParameter("Number of steps");
pParameter->setValue(10);
pParameterGroup->addParameter("Type", CCopasiParameter::UINT);
pParameter=pParameterGroup->getParameter("Type")
pParameter->setValue(CScanProblem::SCAN_REPEAT);
pParameterGroup->addParameter("Object", CCopasiParameter::CN);
pParameter=pParameterGroup->getParameter("Object");
pParameter.setValue("");
try
{
  pScanTask->initialize(CCopasiTask::OUTPUT_COMPLETE, pGobalDataModel, NULL);
  pScanTask->process(true);
  pScanTask->restore();
}
catch(...)
{
    std::cerr &lt;&lt; "ERROR: " &lt;&lt; Scan failed. &lt;&lt; std::endl;;
}</programlisting>
<programlisting condition="PYTHON">
scanTask= datamodel.addTask(CCopasiTask.scan)
scanProblem=scanTask.getProblem()
# set the desired subtask
scanProblem.setSubtask(CCopasiTask.timeCourse)
# always use the same initial values
scanProblem.setAdjustInitialConditions(False)
# get the ScanItems parameter group from the problem
scanItems=scanProblem.getGroup("ScanItems")
# create a new parameter group to hold a scan item
scanItem=new CCopasiParameterGroup("scanItem")
# add the parameters "Number of steps", "Type" and "Object" to the 
# scan item and set their values
parameterGroup.addParameter("Number of steps", CCopasiParameter.UINT)
parameter=parameterGroup.getParameter("Number of steps")
parameter.setValue(10)
parameterGroup.addParameter("Type", CCopasiParameter.UINT)
parameter=parameterGroup.getParameter("Type")
parameter.setUIntValue(CScanProblem.SCAN_REPEAT)
parameterGroup.addParameter("Object", CCopasiParameter.CN)
parameter=parameterGroup.getParameter("Object")
parameter.setStringValue("")
try:
  result=scanTask.process(true)
except:
  print >> sys.stderr, "ERROR while running scan task."
</programlisting>
</para>

<para>
It is important to note that the subtask that is going to be used by the parameter scan has to be set up properly prior to running the parameter scan. That is, if one wants to run a parameter scan on a stochastic simulation, the time course task has to be set up so that it runs a stochastic simulation. Also all other parameters like start time and end time etc. have to be specified for the trajectory task before running the parameter scan.
The same applies to all other subtasks that are or will be enabled in the future.
</para>

<para>
For the task describes so far, one was usually interested in the end result of the task. For parameter scans this is usually different. Here one is normally interested in the result of each calculation of the subtask that the parameter scan is being run on.
Unfortunately those results are not stored in memory, so right now the only way to get these results is to create a report that stores them to a file. For a documentation on how to create reports and how they are connected to a task see the section on reports <link linkend="reports">Creating Reports</link>.
</para>
</sect2>

<sect2 id="optimizations" xreflabel="optimizations">
<title>Running Optimizations</title>

<para>
In order to run an optimization, the general procedure is the same as with the other tasks. One has to acquire or create an instance of <emphasis>COptTask</emphasis>, choose the desired method to use for the task out of the set of methods COPASI provides for the optimization, set the desired parameter values on the instance of <emphasis>COptProblem</emphasis> that can be fetched from the <emphasis>COptTask</emphasis> instance and maybe set some parameter values on the method to change the methods behaviour.
At the time of writing, an optimization can either be done with a time course calculation or a steady state calculation. In order to tell the problem which of the two to use, the problem has a method called setSubtaskType. Valid arguments for the method are CCopasiTask.steadyState or CCopasiTask.timeCourse;
The parameters that can be set on the methods very much depend on the method that is being used. So if you want to find out which parameters each method provides you will have to read the COPASI manual which if you are lucky does list them.
Before running the optimization, two more items have to be set. One is the object that should be optimized, e.g. the initial value of some parameter, the other item is the objective function that the optimization uses the determine the optimal result.
The object(s) that are going to be optimized are determined by one or more instances of <emphasis>COptItem</emphasis>. Each <emphasis>COptItem</emphasis> object stores a reference to the model object to optimize, the start value with which the optimization process will begin and an upper and a lower bound for the value of the object. The optimization method will then try to find values for all objects so that the objective function will (in the optimal case) become minimal.
The objective function itself also needs to be specified before the optimization can be run. The objective function is an expression that COPASI tries to minimize by changing the values of the objects referenced in the specified <emphasis>COptItem</emphasis>s. In order to set the objective function, the <emphasis>COptProblem</emphasis> instance has a method called <emphasis>setObjectiveFunction</emphasis>. This method takes a string that represents the mathematical expression of the function. The mathematical expression can contain all elements that can be used to describe expressions as described in the COPASI manual. Model objects that are used in the expression have to be referenced with their so called common name enclosed in angular brackets (&lt;CN&gt;). To get the common name from an object derived from <emphasis>CCopasiObject</emphasis> the method <emphasis>getCN</emphasis> can be used.
</para>

<para>
Here a small example that runs a simple optimization task:
</para>

<para>
<programlisting condition="JAVA">
<![CDATA[
// create the optimization task
COptTask optTask=
  (COptTask)datamodel.addTask(CCopasiTask.optimization);
if(optTask==null) return null;

// use the Levenberg-Marquardt method for the optimization
optTask.setMethodType(CCopasiMethod.LevenbergMarquardt);

// acquire the problem instance from the task
COptProblem optProblem=(COptProblem)optTask.getProblem();
if(optProblem==null) return null;

// create the objective function
// in this case the objective function is the transient
// value of some model parameter
// so COPASI will try to find values for all COptItems
// so that the transient value of the parameter after
// the simulation is minimal
CCopasiObjectName ref=new CCopasiObjectName("Reference=Value");
CCopasiObject object=SomeVariableModelValue.getObject(ref);
String objectiveFunction=object.getCN().getString();
objectiveFunction="<"+objectiveFunction+">";
// set the objective function on the problem
optProblem.setObjectiveFunction(objectiveFunction);
// set the problems subtask type to indicate that the optimization
// is to be run on a time course simulation
optProblem.setSubtaskType(CCopasiTask.timeCourse);

// create an optimization item for the 
// initial value of some model parameter
ref=new CCopasiObjectName("Reference=InitialValue");
object=SomeFixedModelValue.getObject(ref);
CCopasiObjectName optObjectName=object.getCN();
COptItem optItem2=optProblem.addOptItem(optObjectName);
optItem2.setStartValue(1.0,datamodel);
optItem2.setLowerBound(0.0,datamodel);
optItem2.setUpperBound(2.0,datamodel);

// change some of the parameters of the method
COptMethod optMethod=optTask.getMethod();
param=optMethod.getParameter("Iteration Limit");
param.setIntValue(2000);
param=optMethod.getParameter("Tolerance");
param.setDblValue(1.0e-5);
boolean result=false;
try
{
    // run the optimization
  result=optTask.process(true);
}
catch(Exception e)
{
  System.err.println("ERROR: "+e.getMessage());
}]]>
</programlisting>
<programlisting condition="CPP">
<![CDATA[
// create the optimization task
COptTask* pOptTask=(COptTask*)pDataModel->addTask(CCopasiTask::optimization);
if(pOptTask==NULL) return NULL;

// use the Levenberg-Marquardt method for the optimization
pOptTask->setMethodType(CCopasiMethod::LevenbergMarquardt);

// acquire the problem instance from the task
COptProblem* pOptProblem=(COptProblem*)pOptTask->getProblem();
if(pOptProblem==NULL) return NULL;

// create the objective function
// in this case the objective function is the transient
// value of some model parameter
// so COPASI will try to find values for all COptItems
// so that the transient value of the parameter after
// the simulation is minimal
CCopasiObjectName ref=CCopasiObjectName("Reference=Value");
CCopasiObject* pObject=pModelValue->getObject(ref);
std:string objectiveFunction=pObject->getCN();
objectiveFunction="<"+objectiveFunction+">";
// set the objective function on the problem
pOptProblem->setObjectiveFunction(objectiveFunction);
// set the problems subtask type to indicate that the optimization
// is to be run on a time course simulation
pOptProblem->setSubtaskType(CCopasiTask::timeCourse);

// create an optimization item for the 
// initial value of some model parameter
ref=CCopasiObjectName("Reference=InitialValue");
pObject=pSomeFixedModelValue->getObject(ref);
CCopasiObjectName optObjectName=pObject->getCN();
COptItem* pOptItem2=pOptProblem->addOptItem(optObjectName);
pOptItem2->setStartValue(1.0,datamodel);
pOptItem2->setLowerBound(0.0,datamodel);
pOptItem2->setUpperBound(2.0,datamodel);

// change some of the parameters of the method
COptMethod* pOptMethod=(COptMethod*)pOptTask->getMethod();
CCopsiParameter* pParam=pOptMethod->getParameter("Iteration Limit");
pParam->setValue(2000);
pParam=pOptMethod->getParameter("Tolerance");
pParam->setValue(1.0e-5);
try
{
    // run the optimization
  pOptTask->initialize(CCopasiTask::OUTPUT_COMPLETE, pGobalDataModel, NULL);
  pOptTask->process(true);
  pOptTask->restore();
}
catch(...)
{
  std::cerr << "ERROR: Optimization failed." << std::endl;
}]]>
</programlisting>
<programlisting condition="PYTHON">
<![CDATA[
# create the optimization task
COptTask optTask=datamodel.addTask(CCopasiTask.optimization)
if optTask==None:
   return None

# use the Levenberg-Marquardt method for the optimization
optTask.setMethodType(CCopasiMethod.LevenbergMarquardt)

# acquire the problem instance from the task
optProblem=optTask.getProblem()
if optProblem==None:
    return None

# create the objective function
# in this case the objective function is the transient
# value of some model parameter
# so COPASI will try to find values for all COptItems
# so that the transient value of the parameter after
# the simulation is minimal
ref=CCopasiObjectName("Reference=Value")
object=SomeVariableModelValue.getObject(ref)
objectiveFunction=object.getCN().getString()
objectiveFunction="<"+objectiveFunction+">"
# set the objective function on the problem
optProblem.setObjectiveFunction(objectiveFunction)
# set the problems subtask type to indicate that the optimization
# is to be run on a time course simulation
optProblem.setSubtaskType(CCopasiTask.timeCourse)

# create an optimization item for the 
# initial value of some model parameter
ref=CCopasiObjectName("Reference=InitialValue")
object=SomeFixedModelValue.getObject(ref)
optObjectName=object.getCN()
optItem2=optProblem.addOptItem(optObjectName)
optItem2.setStartValue(1.0,datamodel)
optItem2.setLowerBound(0.0,datamodel)
optItem2.setUpperBound(2.0,datamodel)

# change some of the parameters of the method
optMethod=optTask.getMethod()
param=optMethod.getParameter("Iteration Limit")
param.setIntValue(2000)
param=optMethod.getParameter("Tolerance")
param.setValue(1.0e-5)
result=False
try:
  # run the optimization
  result=optTask.process(True)
except:
  print >> sys.stderr, "ERROR while running optimization." 
]]>
</programlisting>
</para>

<para>
After the optimization has been run, the solution of the optimization is stored in the problem instance.
In order to get the lowest value COPASI was able to find for the objective function, use the call to <emphasis>getSolutionValue</emphasis>.
The values for the <emphasis>COptItem</emphasis> objects corresponding to that result, use <emphasis>getSolutionVariables</emphasis>. This method returns a container with double values. The size of the container can be queried with its <emphasis>size</emphasis> method and individual values can be acquire by calling <emphasis>get</emphasis> with the index of the value. The value for index <emphasis>i</emphasis> belongs to the <emphasis>COptItem</emphasis> with index <emphasis>i</emphasis> in the list of <emphasis>COptItem</emphasis>s.  To get a container with all defined <emphasis>COptItem</emphasis>s, use <emphasis>getOptItemList</emphasis>.
</para>
</sect2>

<sect2 id="parameterFitting" xreflabel="parameterFitting">
<title>Fitting parameters</title>

<para>
Parameter fitting can be used to determine the value of certain model entities with the help of experimental data.
The API for doing parameter fitting is very similar to the one for running an optimization (see above). This is because the classes for parameter fitting are derived from the optimization classes.
This makes sense since the actions for running an optimization are very similar to what COPASI does when doing parameter fitting. The major difference is that for an optimization, the user has to provide an objective function that is minimized whereas for the parameter fitting, the user provides experimental data and some information about the data and COPASI determines the objective function from that information.
</para>

<para>
The first step when doing parameter fitting is to get an instance of <emphasis>CFitTask</emphasis>. Either there is already one in the list of tasks which can be used, or we simplify add one, as demonstrated in the example below.
The <emphasis>CFitTask</emphasis> has the methods <emphasis>getMethod</emphasis> and <emphasis>getProblem</emphasis> which provide the method and the problem for the task.
</para>

<para>
The methods that can be used for parameter fitting should be the same set of methods that is available for the optimization. The methods that are available can be queried with <emphasis>getValidMethods</emphasis> in <emphasis>CFitTask</emphasis> and a specific method can be set with <emphasis>setMethodType</emphasis> also in <emphasis>CFitTask</emphasis>.
</para>

<para>
Most settings for the parameter fitting however are done in the problem. The problem contains a parameter group called <emphasis>Experiment Set</emphasis> which contains the information about the experimental data against which the parameters should be fitted.
The information for each experiment is stored in an instance of <emphasis>CExperiment</emphasis>. The information that needs to be provided for each experment is 
</para>

<para>
<orderedlist>
<listitem><para>the name of the file where the experimental data can be found</para></listitem>
<listitem><para>the row number where the data for the experiment starts</para></listitem>
<listitem><para>the row number where the data for the experiment ends</para></listitem>
<listitem><para>the type of experiment that the data represents (time course or steady state)</para></listitem>
<listitem><para>the number of data columns in the data set</para></listitem>
<listitem><para>the mapping of the columns to the entities in the model and their role</para></listitem>
</orderedlist>
</para>

<para>
Another useful piece of information that can be set for the experiment is the separator that is used in the data file to separate the individual columns. This separator can be set with the <emphasis>setSeparator</emphasis> method in <emphasis>CExperiment</emphasis>. It takes a string as its only argument. One thing to watch out for is the fact that COPASI tries to match the separator exactly. That is, if the separator is set to be one space character, having two space characters between two columns in the file will lead COPASI to think that there is an empty column. Unfortunately there is no way right now to tell COPASI that the delimiter for the columns is e.g. one or more space characters.
</para>

<para>
The information about the mapping from data columns to model entities is stored in an instance of <emphasis>CExperimentObjectmap</emphasis> which can be aquired with the <emphasis>getObjectMap</emphasis> method from <emphasis>CExperiment</emphasis>.
After the information for the experiment has been set, the experiment needs to be added to the experiment set. The <emphasis>addExperiment</emphasis> method creates a copy of the experiment that is added, so make sure that you get the experiment from the experiment set before you make further modifications or use it, e.g. to add it to the fit item (see below).
</para>

<para>
Next we need to create the fit items which correspond to the optimization items in the optimization task. Fit items are instances of <emphasis>CFitItem</emphasis> and they have an upper bound, a lower bound and a start value just like optimization items.
By default each fit item is influenced by all experiments. if you want to limit a fit item to be only influenced by certain experiments, you have to add those experiments to the fit item with the <emphasis>addExperiment</emphasis> method of <emphasis>CFitItem</emphasis>.
</para>

<para>
There is no specialized method to add fit items to the fit problem, so we have to use the generic methods provided be <emphasis>CCopasiParameterGroup</emphasis> to do this. The fit problem contains a parameter group called <emphasis>OptimizationItemList</emphasis> which holds all the fit items. Since the problem itself is derived from <emphasis>CCopasiParameterGroup</emphasis>, we can use the <emphasis>getParameter</emphasis> method with the name of the parameter in order to get the parameter group. Now we can add the fit items with the <emphasis>addParameter</emphasis> method to the group.
Just like the <emphasis>addExperiment</emphasis> method above, this method makes a copy of its argument, so if you are planning to use the fit item again, be sure to get the fit item from the group again.
</para>

<para>
A fit problem can actually contain many experiments and many fit items, but the example code below only uses one experiment and one fit item to fit the reaction parameter of a simple system. The code assumes that the models consists of only one compartment with two species named <emphasis>A</emphasis> and <emphasis>B</emphasis> as well as one reaction with a local reaction parameter (which is fitted).
</para>

<para>
<programlisting condition="JAVA">
CFitTask fitTask=
  (CFitTask)datamodel.addTask(CCopasiTask.parameterFitting);
// the method in a fit task is an instance of COptMethod or a subclass of
// it.
COptMethod fitMethod=(COptMethod)fitTask.getMethod();
// the object must be an instance of COptMethod or a subclass thereof
// (CFitMethod)
CFitProblem fitProblem=(CFitProblem)fitTask.getProblem();
CExperimentSet experimentSet=(CExperimentSet)fitProblem.getParameter("Experiment Set");
// first experiment
CExperiment experiment=new CExperiment(datamodel);
experiment.setFileName("parameter_fitting_data_simple.txt");
experiment.setFirstRow(1);
experiment.setLastRow(22);
experiment.setHeaderRow(1);
experiment.setExperimentType(CCopasiTask.timeCourse);
experiment.setNumColumns(3);
CExperimentObjectMap objectMap=experiment.getObjectMap();
boolean result=objectMap.setNumCols(3);
result=objectMap.setRole(0,CExperiment.time);
CModel model=datamodel.getModel();
// create the common name for time (column 0)
CCopasiObject timeReference=model.getObject(new CCopasiObjectName("Reference=Time"));
objectMap.setObjectCN(0,timeReference.getCN().getString());
CMetab metabA=model.getMetabolite(0);
CMetab metabB=null;
if(metabA.getObjectName()!="A")
{
    metabB=metabA;
    metabA=model.getMetabolite(1);
}
else
{
    metabB=model.getMetabolite(1);
}
// set the role to dependent
objectMap.setRole(1,CExperiment.dependent);
// create the common name for the particle number of A (column 1)
CCopasiObject particleReference=
    metabA.getObject(new CCopasiObjectName("Reference=ParticleNumber"));
objectMap.setObjectCN(1,particleReference.getCN().getString());
// set the role to dependent
objectMap.setRole(2,CExperiment.dependent);
// create the common name for the particle number of B (column 1)
particleReference=metabB.getObject(new CCopasiObjectName("Reference=ParticleNumber"));
objectMap.setObjectCN(2,particleReference.getCN().getString());
// getObjectCN returns a string whereas getCN returns a
// CCopasiObjectname
experimentSet.addExperiment(experiment);
// addExperiment makes a copy, so we need to get the added experiment
// again
experiment=experimentSet.getExperiment(0);

CReaction reaction=model.getReaction(0);
CCopasiParameter parameter=reaction.getParameters().getParameter(0);

// define CFitItems
CCopasiObject parameterReference=
    parameter.getObject(new CCopasiObjectName("Reference=Value"));
CFitItem fitItem=new CFitItem(datamodel);
fitItem.setObjectCN(parameterReference.getCN());
fitItem.setStartValue(4.0);
fitItem.setLowerBound(new CCopasiObjectName("0.0001"),datamodel);
fitItem.setUpperBound(new CCopasiObjectName("10"),datamodel);
// add the experiment to the fit item
//fitItem.addExperiment(experiment.getKey())
// add the fit item to the correct parameter group
CCopasiParameterGroup optimizationItemGroup=
    (CCopasiParameterGroup)fitProblem.getParameter("OptimizationItemList");
optimizationItemGroup.addParameter(fitItem);
// addParameter makes a copy of the fit item, so we have to get it back
fitItem=(CFitItem)optimizationItemGroup.getParameter(0);
result=true;
try
{
  result=fitTask.process(true);
}
catch(Exception e)
{
  result=false;
}
// get the fitted value for the reaction parameter
double fittedK=fitItem.getLocalValue();
</programlisting>
<programlisting condition="CPP">
CFitTask* pFitTask= (CFitTask*)pDataModel->addTask(CCopasiTask::parameterFitting);
// the method in a fit task is an instance of COptMethod or a subclass of
// it.
COptMethod pFitMethod=(COptMethod*)pFitTask->getMethod();
// the object must be an instance of COptMethod or a subclass thereof
// (CFitMethod)
CFitProblem* pFitProblem=(CFitProblem*)pFitTask->getProblem();
CExperimentSet* pExperimentSet=&amp;(CExperimentSet*)pFitProblem->getParameter("Experiment Set");
// first experiment
CExperiment* pExperiment=new CExperiment(pDataModel);
pExperiment->setFileName("parameter_fitting_data_simple.txt");
pExperiment->setFirstRow(1);
pExperiment->setLastRow(22);
pExperiment->setHeaderRow(1);
pExperiment->setExperimentType(CCopasiTask::timeCourse);
pExperiment->setNumColumns(3);
CExperimentObjectMap* pObjectMap=&amp;pExperiment->getObjectMap();
bool result=pObjectMap->setNumCols(3);
result=pObjectMap->setRole(0,CExperiment::time);
CModel* pModel=pDataModel->getModel();
// create the common name for time (column 0)
CCopasiObject* pTimeReference=pModel->getObject(CCopasiObjectName("Reference=Time"));
pObjectMap->setObjectCN(0,pTimeReference->getCN());
CMetab* pMetabA=(*pModel->getMetabolites())[0];
CMetab* pMetabB=NULL;
if(pMetabA->getObjectName()!="A")
{
    pMetabB=pMetabA;
    pMetabA=(*pModel->getMetabolites())[1];
}
else
{
    pMetabB=(*pModel->getMetabolites())[1];
}
// set the role to dependent
pObjectMap->setRole(1,CExperiment::dependent);
// create the common name for the particle number of A (column 1)
CCopasiObject* pParticleReference=pMetabA->getObject(CCopasiObjectName("Reference=ParticleNumber"));
pObjectMap->setObjectCN(1,pParticleReference->getCN());
// set the role to dependent
pObjectMap->setRole(2,CExperiment::dependent);
// create the common name for the particle number of B (column 1)
pParticleReference=pMetabB->getObject(CCopasiObjectName("Reference=ParticleNumber"));
pObjectMap->setObjectCN(2,pParticleReference->getCN());
// getObjectCN returns a string whereas getCN returns a
// CCopasiObjectName
pExperimentSet->addExperiment(pExperiment);
// addExperiment makes a copy, so we need to get the added experiment
// again
delete pExperiment;
pExperiment=pExperimentSet->getExperiment(0);

CReaction* pReaction=(*pModel->getReactions())[0];
CCopasiParameter* pParameter=pReaction->getParameters()->getParameter(0);

// define CFitItems
CCopasiObject* pParameterReference=pParameter->getObject(CCopasiObjectName("Reference=Value"));
CFitItem* pFitItem=new CFitItem(pDataModel);
pFitItem->setObjectCN(pParameterReference->getCN());
pFitItem->setStartValue(4.0);
pFitItem->setLowerBound(CCopasiObjectName("0.0001"),datamodel);
pFitItem->setUpperBound(CCopasiObjectName("10"),datamodel);
// add the fit item to the correct parameter group
CCopasiParameterGroup* pOptimizationItemGroup=(CCopasiParameterGroup*)pFitProblem->getParameter("OptimizationItemList");
pOptimizationItemGroup->addParameter(pFitItem);
// addParameter makes a copy of the fit item, so we have to get it back
delete pFitItem;
pFitItem=(CFitItem*)pOptimizationItemGroup->getParameter(0);
result=true;
try
{
  pFitTask->initialize(CCopasiTask::OUTPUT_COMPLETE, pGobalDataModel, NULL);
  result=pFitTask->process(true);
  pFitTask->restore();
}
catch(...)
{
  result=false;
}
// get the fitted value for the reaction parameter
double fittedK=pFitItem->getLocalValue();
</programlisting>
<programlisting condition="PYTHON">
fitTask=datamodel.addTask(CCopasiTask.parameterFitting)
# the method in a fit task is an instance of COptMethod or a subclass of
# it.
fitMethod=fitTask.getMethod()
# the object must be an instance of COptMethod or a subclass thereof
# (CFitMethod)
fitProblem=fitTask.getProblem()
experimentSet=fitProblem.getParameter("Experiment Set")
# first experiment
experiment=CExperiment(datamodel)
experiment.setFileName("parameter_fitting_data_simple.txt")
experiment.setFirstRow(1)
experiment.setLastRow(22)
experiment.setHeaderRow(1)
experiment.setExperimentType(CCopasiTask.timeCourse)
experiment.setNumColumns(3)
objectMap=experiment.getObjectMap()
result=objectMap.setNumCols(3)
result=objectMap.setRole(0,CExperiment.time)
model=datamodel.getModel()
# create the common name for time (column 0)
timeReference=model.getObject(CCopasiObjectName("Reference=Time"))
objectMap.setObjectCN(0,timeReference.getCN().getString())
metabA=model.getMetabolite(0)
metabB=null
if metabA.getObjectName()!="A":
    metabB=metabA;
    metabA=model.getMetabolite(1);
else:
    metabB=model.getMetabolite(1);
# set the role to dependent
objectMap.setRole(1,CExperiment.dependent)
# create the common name for the particle number of A (column 1)
particleReference=metabA.getObject(CCopasiObjectName("Reference=ParticleNumber"))
objectMap.setObjectCN(1,particleReference.getCN().getString())
# set the role to dependent
objectMap.setRole(2,CExperiment.dependent)
# create the common name for the particle number of B (column 1)
particleReference=metabB.getObject(CCopasiObjectName("Reference=ParticleNumber"))
objectMap.setObjectCN(2,particleReference.getCN().getString())
# getObjectCN returns a string whereas getCN returns a
# CCopasiObjectname
experimentSet.addExperiment(experiment)
# addExperiment makes a copy, so we need to get the added experiment
# again
experiment=experimentSet.getExperiment(0)

reaction=model.getReaction(0)
parameter=reaction.getParameters().getParameter(0)

# define CFitItems
parameterReference=parameter.getObject(CCopasiObjectName("Reference=Value"))
fitItem=CFitItem(datamodel)
fitItem.setObjectCN(parameterReference.getCN())
fitItem.setStartValue(4.0)
fitItem.setLowerBound(new CCopasiObjectName("0.0001"),datamodel)
fitItem.setUpperBound(new CCopasiObjectName("10"),datamodel)
# add the experiment to the fit item
# fitItem.addExperiment(experiment.getKey())
# add the fit item to the correct parameter group
optimizationItemGroup=fitProblem.getParameter("OptimizationItemList")
optimizationItemGroup.addParameter(fitItem)
# addParameter makes a copy of the fit item, so we have to get it back
fitItem=optimizationItemGroup.getParameter(0)
result=True
try:
  result=fitTask.process(true)
except:
  result=False
# get the fitted value for the reaction parameter
fittedK=fitItem.getLocalValue()
</programlisting>
</para>

<para>
After running the fitting task, the fit result is stored in the individual fit items. The best value that was achived during parameter fitting can be queried by the <emphasis>getLocalValue</emphasis> method from each fit item.
</para>
</sect2>
</sect1>


<sect1 id="reports" xreflabel="reports">
<title>Creating Reports</title>

<para>
Sometimes it is necessary to write the results of a calculation to a file instead of keeping it in memory. In order to achieve this, a report for the results has to be created and this report has to be associated with a task.
In COPASI reports are represented by the class <emphasis>CReport</emphasis>. A report stored a so called report definition that specifies what is being written and it contains a filename that determines where the report is written to.
In order to set the filename, you can use the method <emphasis>setTarget</emphasis> with the path of the file as the argument. It is up to the programmer to make sure that the directory part of the path exists and that it is writable.
To set the report definition of a report instance, use the method <emphasis>setReportDefinition</emphasis>. The only argument to the call is an instance of class <emphasis>CReportDefinition</emphasis>.
A report definition can work in two modes. In the default mode, the report definition is a table and all objects that are added to the report definition are written separated by a user definable separator.
In the second mode a report definitions consists of three parts a header, a body and a footer. The part that is specified as the header is written before the associated task is executed, the body is executed for each step of the associated task and the footer is finally written after the task has finished.
Each part is a container that holds zero or more report definition items. To get the individual containers, the <emphasis>CReportDefinition</emphasis> class has the methods <emphasis>getTableAddr</emphasis> if the report definition is in table mode or <emphasis>getHeaderAddr</emphasis>, <emphasis>getBodyAddr</emphasis> and <emphasis>getFooterAddr</emphasis> if it is not in table mode.
To specify whether a report definition is to run in table mode, you can use the method <emphasis>setIsTable</emphasis> which takes a boolean value that determines whether the report definition is a table or not. The flag can be queried with the <emphasis>isTable</emphasis> method.
The individual items are of type <emphasis>CRegisteredObjectName</emphasis>. A new instance of <emphasis>CRegisteredObjectName</emphasis> can be created by calling the constructor with a string that represents the common name of the object that is to written.
If the registered object name should represent a model entity, the string has to be the common name of the object. If you want to add an element the report that represents a simple stirng, you have to create an instance of <emphasis>CCopasiStaticString</emphasis> by calling the constructor of this class with the string that you want to add to the report definition. Once you have an instance of <emphasis>CCopasiStaticString</emphasis>, you can create an instance of <emphasis>CRegisteredObjectName</emphasis> the same way as it is done for other objects, you take the string representation of the common name of your instance of <emphasis>CCopasiStaticString</emphasis> and use it as the argument to the constructor of <emphasis>CRegisteredObjectName</emphasis>.
</para>

<para>
In COPASI the reports definitions are stored in the instances of <emphasis>CCopasiDataModel</emphasis>. To get this list use the method <emphasis>getReportDefinitionList</emphasis> on the instance of <emphasis>CCopasiDataModel</emphasis>.
</para>

<para>
<programlisting condition="JAVA">
datamodel.getReportDefinitionList();
</programlisting>
<programlisting condition="CPP">
pDataModel->getReportDefinitionList();
</programlisting>
<programlisting condition="PYTHON">
datamodel.getReportDefinitionList()
</programlisting>
</para>

<para>
The returned object is a container that stores all report definitions. To create a new report definition, use <emphasis>createReportDefinitions</emphasis> which is a method of the container. The two arguments to the call are the name of the report definition and a description. Once you have a report definition object, you can use <emphasis>setTaskType</emphasis> to set the type of task the report is intended for. The method takes one argument which is one of the task types defined in <emphasis>CCopasiTask</emphasis>, e.g. <emphasis>CCopasiTask.timeCourse</emphasis> for the time course task.
Next you can fill the tree sections (header, body, footer) of the report definition or the table  with whatever has to be written to the output.
Once the report definition is finished, we have to tell the task to use it. This is done through the tasks report object which can be acquire with the <emphasis>getReport()</emphasis> method of <emphasis>CCopasiTask</emphasis>. The returned report object has a method <emphasis>setReportDefinition</emphasis> which takes the report definition object as its argument.
Last but not least, we have to specify a filename where the report is written to which is done with the <emphasis>setTarget</emphasis> method of the same report object.
The following example shows how to create a report for a time course simulation that writes the values of all global parameters as an xhtml file with a table for the values:
</para>

<para>
<programlisting condition="JAVA">
<![CDATA[
...
CReportDefinitionVector reportDefs=datamodel.getReportDefinitionList();
CReportDefinition repDef=reportDefs.createReportDefinition("htmlConc",
                                        "value table in HTML format");
repDef.setIsTable(false);
CCopasiStaticString htmlHeader=new CCopasiStaticString("<?xml version=\"1.0\"" 
 + " encoding=\"UTF-8\"?>\n<!DOCTYPE html PUBLIC "
 + "\"-//W3C//DTD XHTML 1.0 Transitional//EN\" "
 + "\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n"
 + "<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\""
 + "lang=\"en\">\n<body>\n<table>\n");
CCopasiStaticString htmlFooter=new CCopasiStaticString(
                                      "</table>\n</body>\n</html>\n");
ReportItemVector header=repDef.getHeaderAddr(); 
header.add(new CRegisteredObjectName(htmlHeader.getCN().getString()));
ReportItemVector footer=repDef.getFooterAddr(); 
footer.add(new CRegisteredObjectName(htmlFooter.getCN().getString()));
ReportItemVector body=repDef.getBodyAddr(); 
CModel model=datamodel.getModel();
CCopasiObjectName name=new CCopasiObjectName("Reference=Time");
CCopasiObject timeObject=model.getObject(name);
CCopasiStaticString s=new CCopasiStaticString("<tr>\n<td>");
body.add(new CRegisteredObjectName(s.getCN().getString()));
body.add(new CRegisteredObjectName(timeObject.getCN().getString()));
s=new CCopasiStaticString("</td>\n");
body.add(new CRegisteredObjectName(s.getCN().getString()));
name=new CCopasiObjectName("Reference=Value")
long i,iMax=model.getNumModelValues();
for(i=0;i<iMax;++i)
{
    s=new CCopasiStaticString("<td>");
    body.add(new CRegisteredObjectName(s.getCN().getString()));
    CModelValue mv=model.getModelValue(i);
    CCopasiObject valueObject=mv.getObject(name);
    body.add(new CRegisteredObjectName(valueObject.getCN().getString()));
    s=new CCopasiStaticString("</td>\n");
    body.add(new CRegisteredObjectName(s.getCN().getString()));
}
s=new CCopasiStaticString("</tr>\n");
body.add(new CRegisteredObjectName(s.getCN().getString()));
repDef.setTaskType(CCopasiTask.timeCourse);
CReport report=task.getReport();
report.setReportDefinition(repDef);
report.setAppend(false);
report.setTarget("table.xhtml");
 ...]]>
</programlisting>
<programlisting condition="CPP">
<![CDATA[
...
CReportDefinitionVector* pReportDefs=pDataModel->getReportDefinitionList();
CReportDefinition* pRepDef=pReportDefs->createReportDefinition("htmlConc",
                                        "value table in HTML format");
pRepDef->setIsTable(false);
CCopasiStaticString htmlHeader=CCopasiStaticString("<?xml version=\"1.0\"" 
 + " encoding=\"UTF-8\"?>\n<!DOCTYPE html PUBLIC "
 + "\"-//W3C//DTD XHTML 1.0 Transitional//EN\" "
 + "\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n"
 + "<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\""
 + "lang=\"en\">\n<body>\n<table>\n");
CCopasiStaticString htmlFooter=CCopasiStaticString(
                                      "</table>\n</body>\n</html>\n");
std::vector<CRegisteredObjectName>* pHeader=pRepDef->getHeaderAddr(); 
pHeader->add(CRegisteredObjectName(htmlHeader.getCN()));
std::vector<CRegisteredObjectName>* pFooter=pRepDef->getFooterAddr(); 
pFooter->add(new CRegisteredObjectName(htmlFooter.getCN()));
std::vector<CRegisteredObjectName>* pBody=pRepDef->getBodyAddr(); 
CModel* pModel=pDataModel->getModel();
CCopasiObjectName name=CCopasiObjectName("Reference=Time");
CCopasiObject* pTimeObject=pModel->getObject(name);
CCopasiStaticString s=CCopasiStaticString("<tr>\n<td>");
pBody->add(CRegisteredObjectName(s.getCN()));
pBody->add(CRegisteredObjectName(pTimeObject->getCN()));
s=CCopasiStaticString("</td>\n");
pBody->add(CRegisteredObjectName(s.getCN()));
name=CCopasiObjectName("Reference=Value")
long i,iMax=pModel->getModelValues()->size();
for(i=0;i<iMax;++i)
{
    s=CCopasiStaticString("<td>");
    pBody->add(CRegisteredObjectName(s.getCN()));
    CModelValue* pMV=(*pModel->getModelValues())[i];
    CCopasiObject* pValueObject=pMV->getObject(name);
    pBody->add(CRegisteredObjectName(pValueObject->getCN()));
    s=CCopasiStaticString("</td>\n");
    pBody->add(CRegisteredObjectName(s.getCN()));
}
s=CCopasiStaticString("</tr>\n");
pBody->add(CRegisteredObjectName(s.getCN()));
pRepDef->setTaskType(CCopasiTask::timeCourse);
CReport* pReport=&pTask->getReport();
pReport->setReportDefinition(pRepDef);
pReport->setAppend(false);
pReport->setTarget("table.xhtml");
 ...]]>
</programlisting>
<programlisting condition="PYTHON">
<![CDATA[
...
reportDefs=datamodel.getReportDefinitionList()
repDef=reportDefs.createReportDefinition("htmlConc",
                                        "value table in HTML format")
repDef.setIsTable(False)
htmlHeader=CCopasiStaticString("<?xml version=\"1.0\"" 
 + " encoding=\"UTF-8\"?>\n<!DOCTYPE html PUBLIC "
 + "\"-//W3C//DTD XHTML 1.0 Transitional//EN\" "
 + "\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n"
 + "<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\""
 + "lang=\"en\">\n<body>\n<table>\n")
htmlFooter=CCopasiStaticString("</table>\n</body>\n</html>\n")
header=repDef.getHeaderAddr() 
header.push_back(CRegisteredObjectName(htmlHeader.getCN().getString()))
footer=repDef.getFooterAddr()
footer.push_back(CRegisteredObjectName(htmlFooter.getCN().getString()))
body=repDef.getBodyAddr()
model=datamodel.getModel()
name=CCopasiObjectName("Reference=Time")
timeObject=model.getObject(name)
s=CCopasiStaticString("<tr>\n<td>")
body.push_back(CRegisteredObjectName(s.getCN().getString()))
body.push_back(CRegisteredObjectName(timeObject.getCN().getString()))
s=CCopasiStaticString("</td>\n")
body.push_back(CRegisteredObjectName(s.getCN().getString()))
name=CCopasiObjectName("Reference=Value")
iMax=model.getNumModelValues()
for i in range(0,iMax):
    s=CCopasiStaticString("<td>")
    body.push_back(CRegisteredObjectName(s.getCN().getString()))
    mv=model.getModelValue(i)
    valueObject=mv.getObject(name)
    body.push_back(CRegisteredObjectName(valueObject.getCN().getString()))
    s=CCopasiStaticString("</td>\n")
    body.push_back(CRegisteredObjectName(s.getCN().getString()))
s=CCopasiStaticString("</tr>\n")
body.push_back(CRegisteredObjectName(s.getCN().getString()))
repDef.setTaskType(CCopasiTask.timeCourse)
report=task.getReport()
report.setReportDefinition(repDef)
report.setAppend(False)
report.setTarget("table.xhtml")
 ...]]>
</programlisting>
</para>
</sect1>

<sect1 id="errorMessages" xreflabel="errorMessages">
<title>Error Messages</title>

<para>
COPASI uses a message deque to store certain warning and error messages that occur during a process, e.g. during import and export of SBML files.
The methods to work with the message deque are part of the CCopasiMessage class.
</para>

<para>
It is always a good idea to check the message deque after doing complex things like running a certain task, or loading models.
</para>

<para>
The following methods are available to work with the message deque in COPASI.
</para>

<para>
<programlisting condition="JAVA">
/**
 * This static method peeks at the first message created in COPASI.
 * If no more messages are in the deque the message
 * (MCCopasiMessage + 1, "Message (1): No more messages." is returned.
 */
CCopasiMessage peekFirstMessage();

/**
 * This static method peeks at the last message created in COPASI.
 * If no more messages are in the deque the message
 * (MCCopasiMessage + 1, "Message (1): No more messages." is returned.
 */
CCopasiMessage peekLastMessage();

/**
 * This static method retrieves the first message created in COPASI.
 * Consecutive calls allow for the retrieval of all generated
 * messages in chronological order. If no more messages are in
 * the deque the message (MCCopasiMessage + 1, "Message (1):
 * No more messages." is returned.
 */
CCopasiMessage getFirstMessage();

/**
 * This static method retrieves the last message created in COPASI.
 * Consecutive calls allow for the retrieval of all generated
 * messages in reverse chronological order. If no more messages
 * are in the deque the message (MCCopasiMessage + 1, "Message
 * (1): No more messages." is returned.
 */
CCopasiMessage getLastMessage();

/**
 * Static method that retrieves the text of all messages in the deque in chronological
 * or reverse chronological order. If more than on message is in
 * the deque the messages are seperated by an empty line.
 */
String getAllMessageText(boolean chronological);

/**
 * Static method that clears the message deque.
 */
void clearDeque();

/**
 * Static method that retreives the size of the message deque
 */
long size();

/**
 * Static methosd that retrieves the highest severity of the messages in the deque.
 * The returned severity can be CCopasiMessage.RAW, CCopasiMessage.TRACE,
 * CCopasiMessage.COMMANDLINE, CCopasiMessage.WARNING, CCopasiMessage.ERROR,
 * CCopasiMessage.EXCEPTION, CCopasiMessage.RAW_FILTERED,
 * CCopasiMessage.TRACE_FILTERED, CCopasiMessage.COMMANDLINE_FILTERED,
 * CCopasiMessage.WARNING_FILTERED, CCopasiMessage.ERROR_FILTERED or 
 * CCopasiMEssage.EXCEPTION_FILTERED.
 * 
 * The most common of those are WARNING, ERROR or EXCEPTION.
 */
int getHighestSeverity();

/**
 * Static method that checks whether a message with the given number is in the deque
 */
boolean checkForMessage(long number);

/**
 *  Retrieves the text of the message instance.
 */
String getText();

/**
 *  Retrieves the type of the message instance.
 */
int getType();

/**
 *  Retrieves the number of the message instance.
 */
long getNumber();
</programlisting>
<programlisting condition="CPP">
/**
 * This static method peeks at the first message created in COPASI.
 * If no more messages are in the deque the message
 * (MCCopasiMessage + 1, "Message (1): No more messages." is returned.
 */
static const CCopasiMessage&amp; peekFirstMessage();

/**
 * This static method peeks at the last message created in COPASI.
 * If no more messages are in the deque the message
 * (MCCopasiMessage + 1, "Message (1): No more messages." is returned.
 */
static const CCopasiMessage&amp; peekLastMessage();

/**
 * This static method retrieves the first message created in COPASI.
 * Consecutive calls allow for the retrieval of all generated
 * messages in chronological order. If no more messages are in
 * the deque the message (MCCopasiMessage + 1, "Message (1):
 * No more messages." is returned.
 */
static CCopasiMessage getFirstMessage();

/**
 * This static method retrieves the last message created in COPASI.
 * Consecutive calls allow for the retrieval of all generated
 * messages in reverse chronological order. If no more messages
 * are in the deque the message (MCCopasiMessage + 1, "Message
 * (1): No more messages." is returned.
 */
static CCopasiMessage getLastMessage();

/**
 * Static method that retrieves the text of all messages in the deque in chronological
 * or reverse chronological order. If more than on message is in
 * the deque the messages are seperated by an empty line.
 */
static std::string getAllMessageText(const bool&amp; chronological = true);

/**
 * Static method that clears the message deque.
 */
static void clearDeque();

/**
 * Static method that retreives the size of the message deque
 */
static unsigned C_INT32 size();

/**
 * Static methosd that retrieves the highest severity of the messages in the deque.
 * The returned severity can be CCopasiMessage::RAW, CCopasiMessage::TRACE,
 * CCopasiMessage::COMMANDLINE, CCopasiMessage::WARNING, CCopasiMessage::ERROR,
 * CCopasiMessage::EXCEPTION, CCopasiMessage::RAW_FILTERED,
 * CCopasiMessage::TRACE_FILTERED, CCopasiMessage::COMMANDLINE_FILTERED,
 * CCopasiMessage::WARNING_FILTERED, CCopasiMessage::ERROR_FILTERED or 
 * CCopasiMEssage::EXCEPTION_FILTERED.
 * 
 * The most common of those are WARNING, ERROR or EXCEPTION.
 */
static CCopasiMessage::Type getHighestSeverity();

/**
 * Static method that checks whether a message with the given number is in the deque
 */
static bool checkForMessage(const unsigned C_INT32&amp; number);

/**
 *  Retrieves the text of the message instance.
 */
const std::string&amp; getText() const;

/**
 *  Retrieves the type of the message instance.
 */
const CCopasiMessage::Type&amp; getType() const;

/**
 *  Retrieves the number of the message instance.
 */
const unsigned C_INT32&amp; getNumber() const;
</programlisting>
<programlisting condition="PYTHON">
# 
# This static method peeks at the first message created in COPASI.
# If no more messages are in the deque the message
# (MCCopasiMessage + 1, "Message (1): No more messages." is returned.
# 
MESSAGE=peekFirstMessage()

# 
# This static method peeks at the last message created in COPASI.
# If no more messages are in the deque the message
# (MCCopasiMessage + 1, "Message (1): No more messages." is returned.
# 
MESSAGE=peekLastMessage()

# 
# This static method retrieves the first message created in COPASI.
# Consecutive calls allow for the retrieval of all generated
# messages in chronological order. If no more messages are in
# the deque the message (MCCopasiMessage + 1, "Message (1):
# No more messages." is returned.
# 
MESSAGE=getFirstMessage()

# 
# This static method retrieves the last message created in COPASI.
# Consecutive calls allow for the retrieval of all generated
# messages in reverse chronological order. If no more messages
# are in the deque the message (MCCopasiMessage + 1, "Message
# (1): No more messages." is returned.
# 
MESSAGE=getLastMessage()

# 
# Static method that retrieves the text of all messages in the deque in chronological
# or reverse chronological order. If more than on message is in
# the deque the messages are seperated by an empty line.
# 
MESSAGE_TEXT=getAllMessageText(CHRONOLOGICAL)

# 
# Static method that clears the message deque.
# 
clearDeque()

# 
# Static method that retreives the size of the message deque
# 
SIZE=size()

# 
# Static method that retrieves the highest severity of the messages in the deque.
# The returned severity can be CCopasiMessage.RAW, CCopasiMessage.TRACE,
# CCopasiMessage.COMMANDLINE, CCopasiMessage.WARNING, CCopasiMessage.ERROR,
# CCopasiMessage.EXCEPTION, CCopasiMessage.RAW_FILTERED,
# CCopasiMessage.TRACE_FILTERED, CCopasiMessage.COMMANDLINE_FILTERED,
# CCopasiMessage.WARNING_FILTERED, CCopasiMessage.ERROR_FILTERED or 
# CCopasiMEssage.EXCEPTION_FILTERED.
# 
# The most common of those are WARNING, ERROR or EXCEPTION.
# 
SEVERITY=getHighestSeverity()

# 
# Static method that checks whether a message with the given number is in the deque
# 
EXISTS=checkForMessage(MESSAGE_NUMBER)

# 
#  Retrieves the text of the message instance.
# 
TEXT=getText()

# 
#  Retrieves the type of the message instance.
# 
TYPE=getType()

# 
#  Retrieves the number of the message instance.
# 
NUMBER=getNumber()
</programlisting>
</para>

</sect1>
 <sect1 id="programmingExamples" xreflabel="programmingExamples">
<title>Programming Examples</title>
<para>
This section contains some programming examples that might be helpful. We hope that eventually these examples will cover most of the backend.
</para>
<sect2 id="modelCreation" xreflabel="modelCreation">
<title>Creating and saving a model</title>
<para>
This examples shows how to build a simple model with the copasi backend and how it can be saved as either a COPASI file or as an SBML file.
</para>
<para>
<programlisting condition="CPP">
<xi:include  href="../../copasi/bindings/cpp_examples/example1/example1.cpp" xmlns:xi="http://www.w3.org/2001/XInclude" parse="text">
  <xi:fallback>
    <para><emphasis>FIXME:  MISSING XINCLUDE CONTENT</emphasis></para>
  </xi:fallback>
</xi:include>
</programlisting>
<programlisting condition="JAVA">
<xi:include  href="../../copasi/bindings/java/examples/example1.java" xmlns:xi="http://www.w3.org/2001/XInclude" parse="text">
  <xi:fallback>
    <para><emphasis>FIXME:  MISSING XINCLUDE CONTENT</emphasis></para>
  </xi:fallback>
</xi:include>
</programlisting>
<programlisting condition="PYTHON">
<xi:include  href="../../copasi/bindings/python/examples/example1.py" xmlns:xi="http://www.w3.org/2001/XInclude" parse="text">
  <xi:fallback>
    <para><emphasis>FIXME:  MISSING XINCLUDE CONTENT</emphasis></para>
  </xi:fallback>
</xi:include>
</programlisting>
</para>
</sect2>

<sect2 id="modelProcessing" xreflabel="modelProcessing">
<title>Loading and processing a model</title>
<para>
This example shows how a COPASI file can be loaded and the individual model elements can be accessed.
</para>
<para>
<programlisting condition="CPP">
<xi:include  href="../../copasi/bindings/cpp_examples/example2/example2.cpp" xmlns:xi="http://www.w3.org/2001/XInclude" parse="text">
  <xi:fallback>
    <para><emphasis>FIXME:  MISSING XINCLUDE CONTENT</emphasis></para>
  </xi:fallback>
</xi:include>
</programlisting>
<programlisting condition="JAVA">
<xi:include  href="../../copasi/bindings/java/examples/example2.java" xmlns:xi="http://www.w3.org/2001/XInclude" parse="text">
  <xi:fallback>
    <para><emphasis>FIXME:  MISSING XINCLUDE CONTENT</emphasis></para>
  </xi:fallback>
</xi:include>
</programlisting>
<programlisting condition="PYTHON">
<xi:include  href="../../copasi/bindings/python/examples/example2.py" xmlns:xi="http://www.w3.org/2001/XInclude" parse="text">
  <xi:fallback>
    <para><emphasis>FIXME:  MISSING XINCLUDE CONTENT</emphasis></para>
  </xi:fallback>
</xi:include>
</programlisting>
</para>
</sect2>

<sect2 id="timeCourse" xreflabel="timeCourse">
<title>Running a timecourse simulation</title>
<para>
This example shows how a SBML file can be imported and a time course simulation can be run on the model. It also demonstrates how the results from the time course simulation can be accessed. 
</para>
<para>
The example also shows how a report can be defined from the backend in order to get output to a file.
</para>
<para>
<programlisting condition="CPP">
<xi:include  href="../../copasi/bindings/cpp_examples/example3/example3.cpp" xmlns:xi="http://www.w3.org/2001/XInclude" parse="text">
  <xi:fallback>
    <para><emphasis>FIXME:  MISSING XINCLUDE CONTENT</emphasis></para>
  </xi:fallback>
</xi:include>
</programlisting>
<programlisting condition="JAVA">
<xi:include  href="../../copasi/bindings/java/examples/example3.java" xmlns:xi="http://www.w3.org/2001/XInclude" parse="text">
  <xi:fallback>
    <para><emphasis>FIXME:  MISSING XINCLUDE CONTENT</emphasis></para>
  </xi:fallback>
</xi:include>
</programlisting>
<programlisting condition="PYTHON">
<xi:include  href="../../copasi/bindings/python/examples/example3.py" xmlns:xi="http://www.w3.org/2001/XInclude" parse="text">
  <xi:fallback>
    <para><emphasis>FIXME:  MISSING XINCLUDE CONTENT</emphasis></para>
  </xi:fallback>
</xi:include>
</programlisting>
</para>
</sect2>

<sect2 id="scan" xreflabel="scan">
<title>Running a scan over a timecourse simulation</title>
<para>
This example demonstrates importing an SBML model from a string and running a parameter scan over a stochastic time course.
</para>
<para>
The example also shows how a report can be defined from the backend in order to get output to a file.
</para>
<para>
<programlisting condition="CPP">
<xi:include  href="../../copasi/bindings/cpp_examples/example4/example4.cpp" xmlns:xi="http://www.w3.org/2001/XInclude" parse="text">
  <xi:fallback>
    <para><emphasis>FIXME:  MISSING XINCLUDE CONTENT</emphasis></para>
  </xi:fallback>
</xi:include>
</programlisting>
<programlisting condition="JAVA">
<xi:include  href="../../copasi/bindings/java/examples/example4.java" xmlns:xi="http://www.w3.org/2001/XInclude" parse="text">
  <xi:fallback>
    <para><emphasis>FIXME:  MISSING XINCLUDE CONTENT</emphasis></para>
  </xi:fallback>
</xi:include>
</programlisting>
<programlisting condition="PYTHON">
<xi:include  href="../../copasi/bindings/python/examples/example4.py" xmlns:xi="http://www.w3.org/2001/XInclude" parse="text">
  <xi:fallback>
    <para><emphasis>FIXME:  MISSING XINCLUDE CONTENT</emphasis></para>
  </xi:fallback>
</xi:include>
</programlisting>
</para>
</sect2>

<sect2 id="optimization" xreflabel="optimization">
<title>Running an optimization task</title>
<para>
This example shows how to run an optimization task and how to get the results of the optimization after running it.
</para>
<para>
<programlisting condition="CPP">
<xi:include  href="../../copasi/bindings/cpp_examples/example5/example5.cpp" xmlns:xi="http://www.w3.org/2001/XInclude" parse="text">
  <xi:fallback>
    <para><emphasis>FIXME:  MISSING XINCLUDE CONTENT</emphasis></para>
  </xi:fallback>
</xi:include>
</programlisting>
<programlisting condition="JAVA">
<xi:include  href="../../copasi/bindings/java/examples/example5.java" xmlns:xi="http://www.w3.org/2001/XInclude" parse="text">
  <xi:fallback>
    <para><emphasis>FIXME:  MISSING XINCLUDE CONTENT</emphasis></para>
  </xi:fallback>
</xi:include>
</programlisting>
<programlisting condition="PYTHON">
<xi:include  href="../../copasi/bindings/python/examples/example5.py" xmlns:xi="http://www.w3.org/2001/XInclude" parse="text">
  <xi:fallback>
    <para><emphasis>FIXME:  MISSING XINCLUDE CONTENT</emphasis></para>
  </xi:fallback>
</xi:include>
</programlisting>
</para>
</sect2>

<sect2 id="fitting" xreflabel="fitting">
<title>Doing a parameter fit</title>
<para>
This example shows how to fit parameters using the COPASI API.
</para>
<para>
<programlisting condition="CPP">
<xi:include  href="../../copasi/bindings/cpp_examples/example6/example6.cpp" xmlns:xi="http://www.w3.org/2001/XInclude" parse="text">
  <xi:fallback>
    <para><emphasis>FIXME:  MISSING XINCLUDE CONTENT</emphasis></para>
  </xi:fallback>
</xi:include>
</programlisting>
<programlisting condition="JAVA">
<xi:include  href="../../copasi/bindings/java/examples/example6.java" xmlns:xi="http://www.w3.org/2001/XInclude" parse="text">
  <xi:fallback>
    <para><emphasis>FIXME:  MISSING XINCLUDE CONTENT</emphasis></para>
  </xi:fallback>
</xi:include>
</programlisting>
<programlisting condition="PYTHON">
<xi:include  href="../../copasi/bindings/python/examples/example6.py" xmlns:xi="http://www.w3.org/2001/XInclude" parse="text">
  <xi:fallback>
    <para><emphasis>FIXME:  MISSING XINCLUDE CONTENT</emphasis></para>
  </xi:fallback>
</xi:include>
</programlisting>
</para>
</sect2>

<sect2 id="userdefined_functions" xreflabel="userdefined_functions">
<title>Creating and using function definitions</title>
<para>
This example shows how to create a function definition with the COPASI API and how to use it as a kinetic law in a reaction.
</para>
<para>
<programlisting condition="CPP">
<xi:include  href="../../copasi/bindings/cpp_examples/example7/example7.cpp" xmlns:xi="http://www.w3.org/2001/XInclude" parse="text">
  <xi:fallback>
    <para><emphasis>FIXME:  MISSING XINCLUDE CONTENT</emphasis></para>
  </xi:fallback>
</xi:include>
</programlisting>
<programlisting condition="JAVA">
<xi:include  href="../../copasi/bindings/java/examples/example7.java" xmlns:xi="http://www.w3.org/2001/XInclude" parse="text">
  <xi:fallback>
    <para><emphasis>FIXME:  MISSING XINCLUDE CONTENT</emphasis></para>
  </xi:fallback>
</xi:include>
</programlisting>
<programlisting condition="PYTHON">
<xi:include  href="../../copasi/bindings/python/examples/example7.py" xmlns:xi="http://www.w3.org/2001/XInclude" parse="text">
  <xi:fallback>
    <para><emphasis>FIXME:  MISSING XINCLUDE CONTENT</emphasis></para>
  </xi:fallback>
</xi:include>
</programlisting>
</para>
</sect2>

<sect2 id="jacobian" xreflabel="jacobian">
<title>Calculating the jacobian matrix of a model</title>
<para>
This example shows how to calculate the jacobian matrix of a model at an arbitrary state.
</para>
<para>
<programlisting condition="CPP">
<xi:include  href="../../copasi/bindings/cpp_examples/example8/example8.cpp" xmlns:xi="http://www.w3.org/2001/XInclude" parse="text">
  <xi:fallback>
    <para><emphasis>FIXME:  MISSING XINCLUDE CONTENT</emphasis></para>
  </xi:fallback>
</xi:include>
</programlisting>
<programlisting condition="JAVA">
<xi:include  href="../../copasi/bindings/java/examples/example8.java" xmlns:xi="http://www.w3.org/2001/XInclude" parse="text">
  <xi:fallback>
    <para><emphasis>FIXME:  MISSING XINCLUDE CONTENT</emphasis></para>
  </xi:fallback>
</xi:include>
</programlisting>
<programlisting condition="PYTHON">
<xi:include  href="../../copasi/bindings/python/examples/example8.py" xmlns:xi="http://www.w3.org/2001/XInclude" parse="text">
  <xi:fallback>
    <para><emphasis>FIXME:  MISSING XINCLUDE CONTENT</emphasis></para>
  </xi:fallback>
</xi:include>
</programlisting>
</para>
</sect2>

<sect2 id="steadystate_jacobian" xreflabel="steadystate_jacobian">
<title>Calculating the jacobian of a model at the steady state</title>
<para>
This example shows how to calculate the jacobian matrix of a model at the steady state state.
</para>
<para>
<programlisting condition="CPP">
<xi:include  href="../../copasi/bindings/cpp_examples/example9/example9.cpp" xmlns:xi="http://www.w3.org/2001/XInclude" parse="text">
  <xi:fallback>
    <para><emphasis>FIXME:  MISSING XINCLUDE CONTENT</emphasis></para>
  </xi:fallback>
</xi:include>
</programlisting>
<programlisting condition="JAVA">
<xi:include  href="../../copasi/bindings/java/examples/example9.java" xmlns:xi="http://www.w3.org/2001/XInclude" parse="text">
  <xi:fallback>
    <para><emphasis>FIXME:  MISSING XINCLUDE CONTENT</emphasis></para>
  </xi:fallback>
</xi:include>
</programlisting>
<programlisting condition="PYTHON">
<xi:include  href="../../copasi/bindings/python/examples/example9.py" xmlns:xi="http://www.w3.org/2001/XInclude" parse="text">
  <xi:fallback>
    <para><emphasis>FIXME:  MISSING XINCLUDE CONTENT</emphasis></para>
  </xi:fallback>
</xi:include>
</programlisting>
</para>
</sect2>

</sect1>

</chapter>
